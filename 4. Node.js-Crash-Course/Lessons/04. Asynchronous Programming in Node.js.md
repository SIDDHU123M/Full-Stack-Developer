# 04. Asynchronous Programming in Node.js.md

## Asynchronous Patterns

In Node.js, asynchronous programming is essential for handling I/O operations efficiently. There are several patterns for writing asynchronous code:

1. Callbacks: Callback functions are a common way to handle asynchronous operations in Node.js. They allow you to specify what should happen when an operation completes.

```javascript
fs.readFile('file.txt', (err, data) => {
  if (err) {
    console.error(err);
  } else {
    console.log(data);
  }
});
```

2. Promises: Promises provide a more structured way to handle asynchronous operations. They allow you to chain operations and handle success and error cases separately.

```javascript
const readFile = (file) => {
  return new Promise((resolve, reject) => {
    fs.readFile(file, (err, data) => {
      if (err) {
        reject(err);
      } else {
        resolve(data);
      }
    });
  });
};

readFile('file.txt')
  .then((data) => {
    console.log(data);
  })
  .catch((err) => {
    console.error(err);
  });
```

3. async/await: async/await is a modern syntax for writing asynchronous code in a synchronous style. It allows you to write code that looks like synchronous code while still being asynchronous.

```javascript
const readFile = util.promisify(fs.readFile);

const fetchData = async () => {
  try {
    const data = await readFile('file.txt');
    console.log(data);
  } catch (err) {
    console.error(err);
  }
};

fetchData();
```

## Error Handling Strategies

When working with asynchronous code, it's important to handle errors properly. Here are some strategies for error handling:

1. Callbacks: In callback-based code, you can handle errors by checking the error parameter in the callback function.

```javascript
fs.readFile('file.txt', (err, data) => {
  if (err) {
    console.error(err);
  } else {
    console.log(data);
  }
});
```

2. Promises: With promises, you can use the `.catch()` method to handle errors.

```javascript
readFile('file.txt')
  .then((data) => {
    console.log(data);
  })
  .catch((err) => {
    console.error(err);
  });
```

3. async/await: In async/await code, you can use a try-catch block to handle errors.

```javascript
const fetchData = async () => {
  try {
    const data = await readFile('file.txt');
    console.log(data);
  } catch (err) {
    console.error(err);
  }
};

fetchData();
```

Remember to handle errors appropriately to ensure that your application behaves correctly even in the presence of errors.

## Practical examples

### Fetch API data using async/await

```javascript
const fetch = require('node-fetch');

const fetchData = async () => {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (err) {
    console.error(err);
  }
};

fetchData();
```

## Exercises

### Implement error handling in async tasks

```javascript
const asyncTask = async () => {
  try {
    // Perform asynchronous operations here
  } catch (err) {
    console.error(err);
  }
};

asyncTask();
```

In this exercise, implement error handling in the `asyncTask` function. Handle any errors that may occur during the asynchronous operations and log them to the console.

That's it for the lesson on asynchronous programming in Node.js. Practice implementing error handling in async tasks to become more comfortable with asynchronous code.