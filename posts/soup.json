[{"id":51,"date":"2020-06-30T07:39:42","date_gmt":"2020-06-30T07:39:42","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=51"},"modified":"2020-12-16T16:47:32","modified_gmt":"2020-12-16T16:47:32","slug":"home","status":"publish","type":"post","link":"https://python3.foobrdigital.com/home/","title":{"rendered":"Home"},"content":{"rendered":"\n<p>In this tutorial, we will show you, how to perform web scraping in Python using Beautiful Soup 4 for getting data out of HTML, XML and other markup languages. In this we will try to scrap webpage from various different websites (including IMDB). We will cover beautiful soup 4, python basic tools for efficiently and clearly navigating, searching and parsing HTML web page. We have tried to cover almost all the functionalities of Beautiful Soup 4 in this tutorial. You can combine multiple functionalities introduced in this tutorial into one bigger program to capture multiple meaningful data from the website into some other sub-program as input.</p>\n\n\n\n<h1>Audience</h1>\n\n\n\n<p>This tutorial is basically designed to guide you in scarping a web page. Basic requirement of all this is to get meaningful data out of huge unorganized set of data. The target audience of this tutorial can be anyone of:</p>\n\n\n\n<ul><li>Anyone who wants to know – how to scrap webpage in python using BeautifulSoup 4.</li><li>Any data science developer/enthusiasts or anyone, how wants to use this scraped (meaningful) data to different python data science libraries to make better decision.</li></ul>\n\n\n\n<h1>Prerequisites</h1>\n\n\n\n<p>Though there is NO mandatory requirement to have for this tutorial. However, if you have any or all (supercool) prior knowledge on any below mentioned technologies that will be an added advantage −</p>\n\n\n\n<ul><li>Knowledge of any web related technologies (HTML/CSS/Document object Model etc.).</li><li>Python Language (as it is the python package).</li><li>Developers who have any prior knowledge of scraping in any language.</li><li>Basic understanding of HTML tree structure.</li></ul>\n","protected":false},"excerpt":{"rendered":"<p>In this tutorial, we will show you, how to perform web scraping in Python using Beautiful Soup 4 for getting data out of HTML, XML and other markup languages. In this we will try to scrap webpage from various different websites (including IMDB). We will cover beautiful soup 4, python basic tools for efficiently and [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[31,56,129],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/51"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=51"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/51/revisions"}],"predecessor-version":[{"id":2983,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/51/revisions/2983"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=51"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=51"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=51"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":53,"date":"2020-06-30T07:40:40","date_gmt":"2020-06-30T07:40:40","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=53"},"modified":"2020-12-16T16:47:32","modified_gmt":"2020-12-16T16:47:32","slug":"overview-3","status":"publish","type":"post","link":"https://python3.foobrdigital.com/overview-3/","title":{"rendered":"Overview"},"content":{"rendered":"\n<p>In today’s world, we have tons of unstructured data/information (mostly web data) available freely. Sometimes the freely available data is easy to read and sometimes not. No matter how your data is available, web scraping is very useful tool to transform unstructured data into structured data that is easier to read &amp; analyze. In other words, one way to collect, organize and analyze this enormous amount of data is through web scraping. So let us first understand what is web-scraping.</p>\n\n\n\n<h2>What is web-scraping?</h2>\n\n\n\n<p>Scraping is simply a process of extracting (from various means), copying and screening of data.</p>\n\n\n\n<p>When we do scraping or extracting data or feeds from the web (like from web-pages or websites), it is termed as web-scraping.</p>\n\n\n\n<p>So, web scraping which is also known as web data extraction or web harvesting is the extraction of data from web. In short, web scraping provides a way to the developers to collect and analyze data from the internet.</p>\n\n\n\n<h2>Why Web-scraping?</h2>\n\n\n\n<p>Web-scraping provides one of the great tools to automate most of the things a human does while browsing. Web-scraping is used in an enterprise in a variety of ways −</p>\n\n\n\n<h3>Data for Research</h3>\n\n\n\n<p>Smart analyst (like researcher or journalist) uses web scrapper instead of manually collecting and cleaning data from the websites.</p>\n\n\n\n<h3>Products prices &amp; popularity comparison</h3>\n\n\n\n<p>Currently there are couple of services which use web scrappers to collect data from numerous online sites and use it to compare products popularity and prices.</p>\n\n\n\n<h3>SEO Monitoring</h3>\n\n\n\n<p>There are numerous SEO tools such as Ahrefs, Seobility, SEMrush, etc., which are used for competitive analysis and for pulling data from your client’s websites.</p>\n\n\n\n<h3>Search engines</h3>\n\n\n\n<p>There are some big IT companies whose business solely depends on web scraping.</p>\n\n\n\n<h3>Sales and Marketing</h3>\n\n\n\n<p>The data gathered through web scraping can be used by marketers to analyze different niches and competitors or by the sales specialist for selling content marketing or social media promotion services.</p>\n\n\n\n<h2>Why Python for Web Scraping?</h2>\n\n\n\n<p>Python is one of the most popular languages for web scraping as it can handle most of the web crawling related tasks very easily.</p>\n\n\n\n<p>Below are some of the points on why to choose python for web scraping:</p>\n\n\n\n<h3>Ease of Use</h3>\n\n\n\n<p>As most of the developers agree that python is very easy to code. We don’t have to use any curly braces “{ }” or semi-colons “;” anywhere, which makes it more readable and easy-to-use while developing web scrapers.</p>\n\n\n\n<h3>Huge Library Support</h3>\n\n\n\n<p>Python provides huge set of libraries for different requirements, so it is appropriate for web scraping as well as for data visualization, machine learning, etc.</p>\n\n\n\n<h3>Easily Explicable Syntax</h3>\n\n\n\n<p>Python is a very readable programming language as python syntax are easy to understand. Python is very expressive and code indentation helps the users to differentiate different blocks or scoopes in the code.</p>\n\n\n\n<h3>Dynamically-typed language</h3>\n\n\n\n<p>Python is a dynamically-typed language, which means the data assigned to a variable tells, what type of variable it is. It saves lot of time and makes work faster.</p>\n\n\n\n<h3>Huge Community</h3>\n\n\n\n<p>Python community is huge which helps you wherever you stuck while writing code.</p>\n\n\n\n<h2>Introduction to Beautiful Soup</h2>\n\n\n\n<p>The Beautiful Soup is a python library which is named after a Lewis Carroll poem of the same name in “Alice’s Adventures in the Wonderland”. Beautiful Soup is a python package and as the name suggests, parses the unwanted data and helps to organize and format the messy web data by fixing bad HTML and present to us in an easily-traversible XML structures.</p>\n\n\n\n<p>In short, Beautiful Soup is a python package which allows us to pull data out of HTML and XML documents.</p>\n","protected":false},"excerpt":{"rendered":"<p>In today’s world, we have tons of unstructured data/information (mostly web data) available freely. Sometimes the freely available data is easy to read and sometimes not. No matter how your data is available, web scraping is very useful tool to transform unstructured data into structured data that is easier to read &amp; analyze. In other [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[31,56,129],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/53"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=53"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/53/revisions"}],"predecessor-version":[{"id":2982,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/53/revisions/2982"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=53"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=53"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=53"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":55,"date":"2020-06-30T07:48:16","date_gmt":"2020-06-30T07:48:16","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=55"},"modified":"2020-12-16T16:47:32","modified_gmt":"2020-12-16T16:47:32","slug":"installation-4","status":"publish","type":"post","link":"https://python3.foobrdigital.com/installation-4/","title":{"rendered":"Installation"},"content":{"rendered":"\n<p>As BeautifulSoup is not a standard python library, we need to install it first. We are going to install the BeautifulSoup 4 library (also known as BS4), which is the latest one.</p>\n\n\n\n<p>To isolate our working environment so as not to disturb the existing setup, let us first create a virtual environment.</p>\n\n\n\n<h2>Creating a virtual environment (optional)</h2>\n\n\n\n<p>A virtual environment allows us to create an isolated working copy of python for a specific project without affecting the outside setup.</p>\n\n\n\n<p>Best way to install any python package machine is using pip, however, if pip is not installed already (you can check it using – “pip –version” in your command or shell prompt), you can install by giving below command −</p>\n\n\n\n<h3>Linux environment</h3>\n\n\n\n<pre class=\"wp-block-code\"><code>$sudo apt-get install python-pip</code></pre>\n\n\n\n<h3>Windows environment</h3>\n\n\n\n<p>To install pip in windows, do the following −</p>\n\n\n\n<ul><li>Download the get-pip.py from&nbsp;https://bootstrap.pypa.io/get-pip.py&nbsp;or from the github to your computer.</li><li>Open the command prompt and navigate to the folder containing get-pip.py file.</li><li>Run the following command −</li></ul>\n\n\n\n<pre class=\"wp-block-code\"><code>>python get-pip.py</code></pre>\n\n\n\n<p>That’s it, pip is now installed in your windows machine.</p>\n\n\n\n<p>You can verify your pip installed by running below command −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>pip --version\npip 19.2.3 from c:\\users\\yadur\\appdata\\local\\programs\\python\\python37\\lib\\site-packages\\pip (python 3.7)</code></pre>\n\n\n\n<h2>Installing virtual environment</h2>\n\n\n\n<p>Run the below command in your command prompt −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>pip install virtualenv\n﻿</code></pre>\n\n\n\n<p>After running, you will see the below screenshot −</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/beautiful_soup/images/virtualenv.jpg\" alt=\"Virtualenv\"/></figure>\n\n\n\n<p>Below command will create a virtual environment (“myEnv”) in your current directory −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>virtualenv myEnv</code></pre>\n\n\n\n<h3>Screenshot</h3>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/beautiful_soup/images/activate.jpg\" alt=\"Activate\"/></figure>\n\n\n\n<p>To activate your virtual environment, run the following command −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>myEnv\\Scripts\\activate</code></pre>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/beautiful_soup/images/virtual_environment.jpg\" alt=\"Virtual Environment\"/></figure>\n\n\n\n<p>In the above screenshot, you can see we have “myEnv” as prefix which tells us that we are under virtual environment “myEnv”.</p>\n\n\n\n<p>To come out of virtual environment, run deactivate.</p>\n\n\n\n<pre class=\"wp-block-preformatted\">(myEnv) C:\\Users\\yadur&gt;deactivate\nC:\\Users\\yadur&gt;</pre>\n\n\n\n<p>As our virtual environment is ready, now let us install beautifulsoup.</p>\n\n\n\n<h2>Installing BeautifulSoup</h2>\n\n\n\n<p>As BeautifulSoup is not a standard library, we need to install it. We are going to use the BeautifulSoup 4 package (known as bs4).</p>\n\n\n\n<h3>Linux Machine</h3>\n\n\n\n<p>To install bs4 on Debian or Ubuntu linux using system package manager, run the below command −</p>\n\n\n\n<pre class=\"wp-block-preformatted\">$sudo apt-get install python-bs4 (for python 2.x)\n$sudo apt-get install python3-bs4 (for python 3.x)</pre>\n\n\n\n<p>You can install bs4 using easy_install or pip (in case you find problem in installing using system packager).</p>\n\n\n\n<pre class=\"wp-block-code\"><code>$easy_install beautifulsoup4\n$pip install beautifulsoup4</code></pre>\n\n\n\n<p>(You may need to use easy_install3 or pip3 respectively if you’re using python3)</p>\n\n\n\n<h3>Windows Machine</h3>\n\n\n\n<p>To install beautifulsoup4 in windows is very simple, especially if you have pip already installed.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>pip install beautifulsoup4</code></pre>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/beautiful_soup/images/beautifulsoup4.jpg\" alt=\"Beautifulsoup4\"/></figure>\n\n\n\n<p>So now beautifulsoup4 is installed in our machine. Let us talk about some problems encountered after installation.</p>\n\n\n\n<h2>Problems after installation</h2>\n\n\n\n<p>On windows machine you might encounter, wrong version being installed error mainly through −</p>\n\n\n\n<ul><li>error:&nbsp;<strong><em>ImportError “No module named HTMLParser”</em></strong>, then you must be running python 2 version of the code under Python 3.</li><li>error:&nbsp;<strong><em>ImportError “No module named html.parser”&nbsp;</em></strong>error, then you must be running Python 3 version of the code under Python 2.</li></ul>\n\n\n\n<p>Best way to get out of above two situations is to re-install the BeautifulSoup again, completely removing existing installation.</p>\n\n\n\n<p>If you get the&nbsp;<strong><em>SyntaxError “Invalid syntax”</em></strong>&nbsp;on the line ROOT_TAG_NAME = u’[document]’, then you need to convert the python 2 code to python 3, just by either installing the package −</p>\n\n\n\n<pre class=\"wp-block-preformatted\">$ python3 setup.py install\n</pre>\n\n\n\n<p>or by manually running python’s 2 to 3 conversion script on the bs4 directory −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>$ 2to3-3.2 -w bs4</code></pre>\n\n\n\n<h2>Installing a Parser</h2>\n\n\n\n<p>By default, Beautiful Soup supports the HTML parser included in Python’s standard library, however it also supports many external third party python parsers like lxml parser or html5lib parser.</p>\n\n\n\n<p>To install lxml or html5lib parser, use the command −</p>\n\n\n\n<h3>Linux Machine</h3>\n\n\n\n<pre class=\"wp-block-code\"><code>$apt-get install python-lxml\n$apt-get insall python-html5lib</code></pre>\n\n\n\n<h3>Windows Machine</h3>\n\n\n\n<pre class=\"wp-block-code\"><code>$pip install lxml\n$pip install html5lib</code></pre>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/beautiful_soup/images/installing_a_parser.jpg\" alt=\"Installing a Parser\"/></figure>\n\n\n\n<p>Generally, users use lxml for speed and it is recommended to use lxml or html5lib parser if you are using older version of python 2 (before 2.7.3 version) or python 3 (before 3.2.2) as python’s built-in HTML parser is not very good in handling older version.</p>\n\n\n\n<h2>Running Beautiful Soup</h2>\n\n\n\n<p>It is time to test our Beautiful Soup package in one of the html pages (taking web page – https://www.codemeals.com/index.htm, you can choose any-other web page you want) and extract some information from it.</p>\n\n\n\n<p>In the below code, we are trying to extract the title from the webpage −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from bs4 import BeautifulSoup\nimport requests\nurl = \"https://www.codemeals.com/index.htm\"\nreq = requests.get(url)\nsoup = BeautifulSoup(req.text, \"html.parser\")\nprint(soup.title)</code></pre>\n\n\n\n<h3>Output</h3>\n\n\n\n<pre class=\"wp-block-preformatted\">&lt;title&gt;H2O, Colab, Theano, Flutter, KNime, Mean.js, Weka, Solidity, Org.Json, AWS QuickSight, JSON.Simple, Jackson Annotations, Passay, Boon, MuleSoft, Nagios, Matplotlib, Java NIO, PyTorch, SLF4J, Parallax Scrolling, Java Cryptography&lt;/title&gt;\n</pre>\n\n\n\n<p>One common task is to extract all the URLs within a webpage. For that we just need to add the below line of code −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>for link in soup.find_all('a'):\nprint(link.get('href'))</code></pre>\n\n\n\n<h3>Output</h3>\n\n\n\n<pre class=\"wp-block-code\"><code>https:&#47;&#47;www.codemeals.com/index.htm\nhttps://www.codemeals.com/about/about_careers.htm\nhttps://www.codemeals.com/questions/index.php\nhttps://www.codemeals.com/online_dev_tools.htm\nhttps://www.codemeals.com/codingground.htm\nhttps://www.codemeals.com/current_affairs.htm\nhttps://www.codemeals.com/upsc_ias_exams.htm\nhttps://www.codemeals.com/tutor_connect/index.php\nhttps://www.codemeals.com/whiteboard.htm\nhttps://www.codemeals.com/netmeeting.php\nhttps://www.codemeals.com/index.htm\nhttps://www.codemeals.com/tutorialslibrary.htm\nhttps://www.codemeals.com/videotutorials/index.php\nhttps://store.codemeals.com\nhttps://www.codemeals.com/gate_exams_tutorials.htm\nhttps://www.codemeals.com/html_online_training/index.asp\nhttps://www.codemeals.com/css_online_training/index.asp\nhttps://www.codemeals.com/3d_animation_online_training/index.asp\nhttps://www.codemeals.com/swift_4_online_training/index.asp\nhttps://www.codemeals.com/blockchain_online_training/index.asp\nhttps://www.codemeals.com/reactjs_online_training/index.asp\nhttps://www.tutorix.com\nhttps://www.codemeals.com/videotutorials/top-courses.php\nhttps://www.codemeals.com/the_full_stack_web_development/index.asp\n….\n….\nhttps://www.codemeals.com/online_dev_tools.htm\nhttps://www.codemeals.com/free_web_graphics.htm\nhttps://www.codemeals.com/online_file_conversion.htm\nhttps://www.codemeals.com/netmeeting.php\nhttps://www.codemeals.com/free_online_whiteboard.htm\n<blockquote class=\"wp-embedded-content\" data-secret=\"mJp3QBFzjr\"><a href=\"https://codemeals.com/\">Home 5</a></blockquote><iframe class=\"wp-embedded-content\" sandbox=\"allow-scripts\" security=\"restricted\" style=\"position: absolute; clip: rect(1px, 1px, 1px, 1px);\" title=\"&#8220;Home 5&#8221; &#8212; Codemeals\" src=\"https://codemeals.com/embed/#?secret=mJp3QBFzjr\" data-secret=\"mJp3QBFzjr\" width=\"580\" height=\"327\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\"></iframe>\nhttps://www.facebook.com/codemeals india\nhttps://plus.google.com/u/0/+codemeals\n<a class=\"twitter-timeline\" data-width=\"580\" data-height=\"870\" data-dnt=\"true\" href=\"https://twitter.com/codemeals?ref_src=twsrc%5Etfw\">Tweets by codemeals</a><script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\nhttp://www.linkedin.com/company/codemeals\nhttps://www.youtube.com/channel/UCVLbzhxVTiTLiVKeGV7WEBg\nhttps://www.codemeals.com/index.htm\n/about/about_privacy.htm#cookies\n/about/faq.htm\n/about/about_helping.htm\n/about/contact_us.htm\n﻿</code></pre>\n\n\n\n<p>Similarly, we can extract useful information using beautifulsoup4.</p>\n\n\n\n<p>Now let us understand more about “soup” in above example.</p>\n","protected":false},"excerpt":{"rendered":"<p>As BeautifulSoup is not a standard python library, we need to install it first. We are going to install the BeautifulSoup 4 library (also known as BS4), which is the latest one. To isolate our working environment so as not to disturb the existing setup, let us first create a virtual environment. Creating a virtual [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[31,56,129],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/55"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=55"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/55/revisions"}],"predecessor-version":[{"id":2981,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/55/revisions/2981"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=55"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=55"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=55"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":57,"date":"2020-06-30T07:53:18","date_gmt":"2020-06-30T07:53:18","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=57"},"modified":"2020-12-16T16:47:32","modified_gmt":"2020-12-16T16:47:32","slug":"souping-the-page","status":"publish","type":"post","link":"https://python3.foobrdigital.com/souping-the-page/","title":{"rendered":"Souping the Page"},"content":{"rendered":"\n<p>In the previous code example, we parse the document through beautiful constructor using a string method. Another way is to pass the document through open filehandle.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from bs4 import BeautifulSoup\nwith open(\"example.html\") as fp:\n   soup = BeautifulSoup(fp)\nsoup = BeautifulSoup(\"&lt;html>data&lt;/html>\")</code></pre>\n\n\n\n<p>First the document is converted to Unicode, and HTML entities are converted to Unicode characters:&lt;/p&gt;</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import bs4\nhtml = '''&lt;b>codemeals&lt;/b>, &lt;i>&amp;web scraping &amp;data science;&lt;/i>'''\nsoup = bs4.BeautifulSoup(html, 'lxml')\nprint(soup)</code></pre>\n\n\n\n<h2>Output</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;html>&lt;body>&lt;b>codemeals&lt;/b>, &lt;i>&amp;web scraping &amp;data science;&lt;/i>&lt;/body>&lt;/html>\n</code></pre>\n\n\n\n<p>BeautifulSoup then parses the data using HTML parser or you explicitly tell it to parse using an XML parser.</p>\n\n\n\n<h2>HTML tree Structure</h2>\n\n\n\n<p>Before we look into different components of a HTML page, let us first understand the HTML tree structure.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/beautiful_soup/images/html_tree_structure.jpg\" alt=\"HTML Tree Structure\"/></figure>\n\n\n\n<p>The root element in the document tree is the html, which can have parents, children and siblings and this determines by its position in the tree structure. To move among HTML elements, attributes and text, you have to move among nodes in your tree structure.</p>\n\n\n\n<p>Let us suppose the webpage is as shown below −</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/beautiful_soup/images/tutorialspoint_online_library.jpg\" alt=\"Tutorialspoint Online Library\"/></figure>\n\n\n\n<p>Which translates to an html document as follows −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;html>&lt;head>&lt;title>Codemeals&lt;/title>&lt;/head>&lt;h1>Codemeals Online Library&lt;/h1>&lt;p&lt;&lt;b>It's all Free&lt;/b>&lt;/p>&lt;/body>&lt;/html></code></pre>\n\n\n\n<p>Which simply means, for above html document, we have a html tree structure as follows −</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/beautiful_soup/images/html_document.jpg\" alt=\"HTML Document\"/></figure>\n","protected":false},"excerpt":{"rendered":"<p>In the previous code example, we parse the document through beautiful constructor using a string method. Another way is to pass the document through open filehandle. First the document is converted to Unicode, and HTML entities are converted to Unicode characters:&lt;/p&gt; Output BeautifulSoup then parses the data using HTML parser or you explicitly tell it [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[31,56,129],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/57"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=57"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/57/revisions"}],"predecessor-version":[{"id":2980,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/57/revisions/2980"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=57"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=57"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=57"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":59,"date":"2020-06-30T08:00:33","date_gmt":"2020-06-30T08:00:33","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=59"},"modified":"2020-12-16T16:47:32","modified_gmt":"2020-12-16T16:47:32","slug":"kinds-of-objects","status":"publish","type":"post","link":"https://python3.foobrdigital.com/kinds-of-objects/","title":{"rendered":"Kinds of objects"},"content":{"rendered":"\n<p>When we passed a html document or string to a beautifulsoup constructor, beautifulsoup basically converts a complex html page into different python objects. Below we are going to discuss four major kinds of objects:</p>\n\n\n\n<ul><li>Tag</li><li>NavigableString</li><li>BeautifulSoup</li><li>Comments</li></ul>\n\n\n\n<h3>Tag Objects</h3>\n\n\n\n<p>A HTML tag is used to define various types of content. A tag object in BeautifulSoup corresponds to an HTML or XML tag in the actual page or document.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> from bs4 import BeautifulSoup\n>>> soup = BeautifulSoup('&lt;b class=\"boldest\">Codemeals&lt;/b>')\n>>> tag = soup.html\n>>> type(tag)\n&lt;class 'bs4.element.Tag'></code></pre>\n\n\n\n<p>Tags contain lot of attributes and methods and two important features of a tag are its name and attributes.</p>\n\n\n\n<h3>Name (tag.name)</h3>\n\n\n\n<p>Every tag contains a name and can be accessed through ‘.name’ as suffix. tag.name will return the type of tag it is.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> tag.name\n'html'</code></pre>\n\n\n\n<p>However, if we change the tag name, same will be reflected in the HTML markup generated by the BeautifulSoup.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> tag.name = \"Strong\"\n>>> tag\n&lt;Strong>&lt;body>&lt;b class=\"boldest\">Codemeals&lt;/b>&lt;/body>&lt;/Strong>\n>>> tag.name\n'Strong'</code></pre>\n\n\n\n<h3>Attributes (tag.attrs)</h3>\n\n\n\n<p>A tag object can have any number of attributes. The tag &lt;b class=”boldest”&gt; has an attribute ‘class’ whose value is “boldest”. Anything that is NOT tag, is basically an attribute and must contain a value. You can access the attributes either through accessing the keys (like accessing “class” in above example) or directly accessing through “.attrs”</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> tutorialsP = BeautifulSoup(\"&lt;div class='tutorialsP'>&lt;/div>\",'lxml')\n>>> tag2 = tutorialsP.div\n>>> tag2&#91;'class']\n&#91;'tutorialsP']</code></pre>\n\n\n\n<p>We can do all kind of modifications to our tag’s attributes (add/remove/modify).</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> tag2&#91;'class'] = 'Online-Learning'\n>>> tag2&#91;'style'] = '2007'\n>>>\n>>> tag2\n&lt;div class=\"Online-Learning\" style=\"2007\">&lt;/div>\n>>> del tag2&#91;'style']\n>>> tag2\n&lt;div class=\"Online-Learning\">&lt;/div>\n>>> del tag&#91;'class']\n>>> tag\n&lt;b SecondAttribute=\"2\">Codemeals&lt;/b>\n>>>\n>>> del tag&#91;'SecondAttribute']\n>>> tag\n&lt;/b>\n>>> tag2&#91;'class']\n'Online-Learning'\n>>> tag2&#91;'style']\nKeyError: 'style'</code></pre>\n\n\n\n<h2>Multi-valued attributes</h2>\n\n\n\n<p>Some of the HTML5 attributes can have multiple values. Most commonly used is the class-attribute which can have multiple CSS-values. Others include ‘rel’, ‘rev’, ‘headers’, ‘accesskey’ and ‘accept-charset’. The multi-valued attributes in beautiful soup are shown as list.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> from bs4 import BeautifulSoup\n>>>\n>>> css_soup = BeautifulSoup('&lt;p class=\"body\">&lt;/p>')\n>>> css_soup.p&#91;'class']\n&#91;'body']\n>>>\n>>> css_soup = BeautifulSoup('&lt;p class=\"body bold\">&lt;/p>')\n>>> css_soup.p&#91;'class']\n&#91;'body', 'bold']</code></pre>\n\n\n\n<p>However, if any attribute contains more than one value but it is not multi-valued attributes by any-version of HTML standard, beautiful soup will leave the attribute alone −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> id_soup = BeautifulSoup('&lt;p id=\"body bold\">&lt;/p>')\n>>> id_soup.p&#91;'id']\n'body bold'\n>>> type(id_soup.p&#91;'id'])\n&lt;class 'str'></code></pre>\n\n\n\n<p>You can consolidate multiple attribute values if you turn a tag to a string.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> rel_soup = BeautifulSoup(\"&lt;p> codemeals Main &lt;a rel='Index'> Page&lt;/a>&lt;/p>\")\n>>> rel_soup.a&#91;'rel']\n&#91;'Index']\n>>> rel_soup.a&#91;'rel'] = &#91;'Index', ' Online Library, Its all Free']\n>>> print(rel_soup.p)\n&lt;p> codemeals Main &lt;a rel=\"Index Online Library, Its all Free\"> Page&lt;/a>&lt;/p></code></pre>\n\n\n\n<p>By using ‘get_attribute_list’, you get a value that is always a list, string, irrespective of whether it is a multi-valued or not.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>id_soup.p.get_attribute_list(‘id’)</code></pre>\n\n\n\n<p>However, if you parse the document as ‘xml’, there are no multi-valued attributes −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> xml_soup = BeautifulSoup('&lt;p class=\"body bold\">&lt;/p>', 'xml')\n>>> xml_soup.p&#91;'class']\n'body bold'</code></pre>\n\n\n\n<h2>NavigableString</h2>\n\n\n\n<p>The navigablestring object is used to represent the contents of a tag. To access the contents, use “.string” with tag.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> from bs4 import BeautifulSoup\n>>> soup = BeautifulSoup(\"&lt;h2 id='message'>Hello, Codemeals!&lt;/h2>\")\n>>>\n>>> soup.string\n'Hello, Codemeals!'\n>>> type(soup.string)\n></code></pre>\n\n\n\n<p>You can replace the string with another string but you can’t edit the existing string.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> soup = BeautifulSoup(\"&lt;h2 id='message'>Hello, Codemeals!&lt;/h2>\")\n>>> soup.string.replace_with(\"Online Learning!\")\n'Hello, Codemeals!'\n>>> soup.string\n'Online Learning!'\n>>> soup\n&lt;html>&lt;body>&lt;h2 id=\"message\">Online Learning!&lt;/h2>&lt;/body>&lt;/html></code></pre>\n\n\n\n<h2>BeautifulSoup</h2>\n\n\n\n<p>BeautifulSoup is the object created when we try to scrape a web resource. So, it is the complete document which we are trying to scrape. Most of the time, it is treated tag object.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> from bs4 import BeautifulSoup\n>>> soup = BeautifulSoup(\"&lt;h2 id='message'>Hello, Codemeals!&lt;/h2>\")\n>>> type(soup)\n&lt;class 'bs4.BeautifulSoup'>\n>>> soup.name\n'&#91;document]'</code></pre>\n\n\n\n<h2>Comments</h2>\n\n\n\n<p>The comment object illustrates the comment part of the web document. It is just a special type of NavigableString.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> soup = BeautifulSoup('&lt;p>&lt;!-- Everything inside it is COMMENTS -->&lt;/p>')\n>>> comment = soup.p.string\n>>> type(comment)\n&lt;class 'bs4.element.Comment'>\n>>> type(comment)\n&lt;class 'bs4.element.Comment'>\n>>> print(soup.p.prettify())\n&lt;p>\n&lt;!-- Everything inside it is COMMENTS -->\n&lt;/p></code></pre>\n\n\n\n<h2>NavigableString Objects</h2>\n\n\n\n<p>The navigablestring objects are used to represent text within tags, rather than the tags themselves.</p>\n","protected":false},"excerpt":{"rendered":"<p>When we passed a html document or string to a beautifulsoup constructor, beautifulsoup basically converts a complex html page into different python objects. Below we are going to discuss four major kinds of objects: Tag NavigableString BeautifulSoup Comments Tag Objects A HTML tag is used to define various types of content. A tag object in [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[31,56,129],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/59"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=59"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/59/revisions"}],"predecessor-version":[{"id":2979,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/59/revisions/2979"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=59"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=59"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=59"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":61,"date":"2020-06-30T08:12:54","date_gmt":"2020-06-30T08:12:54","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=61"},"modified":"2020-12-16T16:47:32","modified_gmt":"2020-12-16T16:47:32","slug":"navigating-by-tags","status":"publish","type":"post","link":"https://python3.foobrdigital.com/navigating-by-tags/","title":{"rendered":"Navigating by Tags"},"content":{"rendered":"\n<p>In this chapter, we shall discuss about Navigating by Tags.</p>\n\n\n\n<p>Below is our html document −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> html_doc = \"\"\"\n&lt;html>&lt;head>&lt;title>Codemeals&lt;/title>&lt;/head>\n&lt;body>\n&lt;p class=\"title\">&lt;b>The Biggest Online Tutorials Library, It's all Free&lt;/b>&lt;/p>\n&lt;p class=\"prog\">Top 5 most used Programming Languages are:\n&lt;a href=\"https://www.codemeals.com/java/java_overview.htm\" class=\"prog\" id=\"link1\">Java&lt;/a>,\n&lt;a href=\"https://www.codemeals.com/cprogramming/index.htm\" class=\"prog\" id=\"link2\">C&lt;/a>,\n&lt;a href=\"https://www.codemeals.com/python/index.htm\" class=\"prog\" id=\"link3\">Python&lt;/a>,\n&lt;a href=\"https://www.codemeals.com/javascript/javascript_overview.htm\" class=\"prog\" id=\"link4\">JavaScript&lt;/a> and\n&lt;a href=\"https://www.codemeals.com/ruby/index.htm\" class=\"prog\" id=\"link5\">C&lt;/a>;\nas per online survey.&lt;/p>\n&lt;p class=\"prog\">Programming Languages&lt;/p>\n\"\"\"\n>>>\n>>> from bs4 import BeautifulSoup\n>>> soup = BeautifulSoup(html_doc, 'html.parser')\n>>></code></pre>\n\n\n\n<p>Based on the above document, we will try to move from one part of document to another.</p>\n\n\n\n<h2>Going down</h2>\n\n\n\n<p>One of the important pieces of element in any piece of HTML document are tags, which may contain other tags/strings (tag’s children). Beautiful Soup provides different ways to navigate and iterate over’s tag’s children.</p>\n\n\n\n<h3>Navigating using tag names</h3>\n\n\n\n<p>Easiest way to search a parse tree is to search the tag by its name. If you want the &lt;head&gt; tag, use soup.head −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> soup.head\n&lt;head>&amp;t;title>Tutorials Point&lt;/title>&lt;/head>\n>>> soup.title\n&lt;title>Tutorials Point&lt;/title></code></pre>\n\n\n\n<p>To get specific tag (like first &lt;b&gt; tag) in the &lt;body&gt; tag.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> soup.body.b\n&lt;b>The Biggest Online Tutorials Library, It's all Free&lt;/b></code></pre>\n\n\n\n<p>Using a tag name as an attribute will give you only the first tag by that name −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> soup.a\n&lt;a class=\"prog\" href=\"https://www.codemeals.com/java/java_overview.htm\" id=\"link1\">Java&lt;/a></code></pre>\n\n\n\n<p>To get all the tag’s attribute, you can use find_all() method −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> soup.find_all(\"a\")\n&#91;&lt;a class=\"prog\" href=\"https://www.codemeals.com/java/java_overview.htm\" id=\"link1\">Java&lt;/a>, &lt;a class=\"prog\" href=\"https://www.codemeals.com/cprogramming/index.htm\" id=\"link2\">C&lt;/a>, &lt;a class=\"prog\" href=\"https://www.codemeals.com/python/index.htm\" id=\"link3\">Python&lt;/a>, &lt;a class=\"prog\" href=\"https://www.codemeals.com/javascript/javascript_overview.htm\" id=\"link4\">JavaScript&lt;/a>, &lt;a class=\"prog\" href=\"https://www.codemeals.com/ruby/index.htm\" id=\"link5\">C&lt;/a>]>>> soup.find_all(\"a\")\n&#91;&lt;a class=\"prog\" href=\"https://www.codemeals.com/java/java_overview.htm\" id=\"link1\">Java&lt;/a>, &lt;a class=\"prog\" href=\"https://www.codemeals.com/cprogramming/index.htm\" id=\"link2\">C&lt;/a>, &lt;a class=\"prog\" href=\"https://www.codemeals.com/python/index.htm\" id=\"link3\">Python&lt;/a>, &lt;a class=\"prog\" href=\"https://www.codemeals.com/javascript/javascript_overview.htm\" id=\"link4\">JavaScript&lt;/a>, &lt;a class=\"prog\" href=\"https://www.codemeals.com/ruby/index.htm\" id=\"link5\">C&lt;/a>]</code></pre>\n\n\n\n<h2>.contents and .children</h2>\n\n\n\n<p>We can search tag’s children in a list by its .contents −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> head_tag = soup.head\n>>> head_tag\n&lt;head>&lt;title>Tutorials Point&lt;/title>&lt;/head>\n>>> Htag = soup.head\n>>> Htag\n&lt;head>&lt;title>Tutorials Point&lt;/title>&lt;/head>\n>>>\n>>> Htag.contents\n&#91;&lt;title>Tutorials Point&lt;/title>\n>>>\n>>> Ttag = head_tag.contents&#91;0]\n>>> Ttag\n&lt;title>Tutorials Point&lt;/title>\n>>> Ttag.contents\n&#91;'Tutorials Point']</code></pre>\n\n\n\n<p>The BeautifulSoup object itself has children. In this case, the &lt;html&gt; tag is the child of the BeautifulSoup object −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> len(soup.contents)\n2\n>>> soup.contents&#91;1].name\n'html'</code></pre>\n\n\n\n<p>A string does not have .contents, because it can’t contain anything −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> text = Ttag.contents&#91;0]\n>>> text.contents\nself.__class__.__name__, attr))\nAttributeError: 'NavigableString' object has no attribute 'contents'</code></pre>\n\n\n\n<p>Instead of getting them as a list, use .children generator to access tag’s children −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> for child in Ttag.children:\nprint(child)\nTutorials Point</code></pre>\n\n\n\n<h2>.descendants</h2>\n\n\n\n<p>The .descendants attribute allows you to iterate over all of a tag’s children, recursively −</p>\n\n\n\n<p>its direct children and the children of its direct children and so on −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> for child in Htag.descendants:\nprint(child)\n&lt;title>Tutorials Point&lt;/title>\nTutorials Point\n﻿</code></pre>\n\n\n\n<p>The &lt;head&gt; tag has only one child, but it has two descendants: the &lt;title&gt; tag and the &lt;title&gt; tag’s child. The beautifulsoup object has only one direct child (the &lt;html&gt; tag), but it has a whole lot of descendants −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> len(list(soup.children))\n2\n>>> len(list(soup.descendants))\n33</code></pre>\n\n\n\n<h2>.string</h2>\n\n\n\n<p>If the tag has only one child, and that child is a NavigableString, the child is made available as .string −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> Ttag.string\n'Tutorials Point'</code></pre>\n\n\n\n<p>If a tag’s only child is another tag, and that tag has a .string, then the parent tag is considered to have the same .string as its child −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> Htag.contents\n&#91;&lt;title>Tutorials Point&lt;/title>]\n>>>\n>>> Htag.string\n'Tutorials Point'</code></pre>\n\n\n\n<p>However, if a tag contains more than one thing, then it’s not clear what .string should refer to, so .string is defined to None −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> print(soup.html.string)\nNone\n﻿</code></pre>\n\n\n\n<h2>.strings and stripped_strings</h2>\n\n\n\n<p>If there’s more than one thing inside a tag, you can still look at just the strings. Use the .strings generator −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> for string in soup.strings:\nprint(repr(string))\n'\\n'\n'Tutorials Point'\n'\\n'\n'\\n'\n\"The Biggest Online Tutorials Library, It's all Free\"\n'\\n'\n'Top 5 most used Programming Languages are: \\n'\n'Java'\n',\\n'\n'C'\n',\\n'\n'Python'\n',\\n'\n'JavaScript'\n' and\\n'\n'C'\n';\\n \\nas per online survey.'\n'\\n'\n'Programming Languages'\n'\\n'</code></pre>\n\n\n\n<p>To remove extra whitespace, use .stripped_strings generator −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> for string in soup.stripped_strings:\nprint(repr(string))\n'Tutorials Point'\n\"The Biggest Online Tutorials Library, It's all Free\"\n'Top 5 most used Programming Languages are:'\n'Java'\n','\n'C'\n','\n'Python'\n','\n'JavaScript'\n'and'\n'C'\n';\\n \\nas per online survey.'\n'Programming Languages'</code></pre>\n\n\n\n<h2>Going up</h2>\n\n\n\n<p>In a “family tree” analogy, every tag and every string has a parent: the tag that contain it:</p>\n\n\n\n<h3>.parent</h3>\n\n\n\n<p>To access the element’s parent element, use .parent attribute.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> Ttag = soup.title\n>>> Ttag\n&lt;title>Tutorials Point&lt;/title>\n>>> Ttag.parent\n&lt;head>title>Tutorials Point&lt;/title>&lt;/head></code></pre>\n\n\n\n<p>In our html_doc, the title string itself has a parent: the &lt;title&gt; tag that contain it−</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> Ttag.string.parent\n&lt;title>Tutorials Point&lt;/title></code></pre>\n\n\n\n<p>The parent of a top-level tag like &lt;html&gt; is the Beautifulsoup object itself −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> htmltag = soup.html\n>>> type(htmltag.parent)\n&lt;class 'bs4.BeautifulSoup'></code></pre>\n\n\n\n<p>The .parent of a Beautifulsoup object is defined as None −</p>\n\n\n\n<pre class=\"wp-block-preformatted\">&gt;&gt;&gt; print(soup.parent)\nNone\n</pre>\n\n\n\n<h3>.parents</h3>\n\n\n\n<p>To iterate over all the parents elements, use .parents attribute.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> link = soup.a\n>>> link\n&lt;a class=\"prog\" href=\"https://www.codemeals.com/java/java_overview.htm\" id=\"link1\">Java&lt;/a>\n>>>\n>>> for parent in link.parents:\nif parent is None:\nprint(parent)\nelse:\nprint(parent.name)\np\nbody\nhtml\n&#91;document]</code></pre>\n\n\n\n<h2>Going sideways</h2>\n\n\n\n<p>Below is one simple document −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> sibling_soup = BeautifulSoup(\"&lt;a>&lt;b>Codemeals&lt;/b>&lt;c>&lt;strong>The Biggest Online Tutorials Library, It's all Free&lt;/strong>&lt;/b>&lt;/a>\")\n>>> print(sibling_soup.prettify())\n&lt;html>\n&lt;body>\n   &lt;a>\n      &lt;b>\n         Codemeals\n      &lt;/b>\n      &lt;c>\n         &lt;strong>\n            The Biggest Online Tutorials Library, It's all Free\n         &lt;/strong>\n      &lt;/c>\n   &lt;/a>\n&lt;/body>\n&lt;/html></code></pre>\n\n\n\n<p>In the above doc, &lt;b&gt; and &lt;c&gt; tag is at the same level and they are both children of the same tag. Both &lt;b&gt; and &lt;c&gt; tag are siblings.</p>\n\n\n\n<h3>.next_sibling and .previous_sibling</h3>\n\n\n\n<p>Use .next_sibling and .previous_sibling to navigate between page elements that are on the same level of the parse tree:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> sibling_soup.b.next_sibling\n&lt;c>&lt;strong>The Biggest Online Tutorials Library, It's all Free&lt;/strong>&lt;/c>\n>>>\n>>> sibling_soup.c.previous_sibling\n&lt;b>Codemeals&lt;/b></code></pre>\n\n\n\n<p>The &lt;b&gt; tag has a .next_sibling but no .previous_sibling, as there is nothing before the &lt;b&gt; tag on the same level of the tree, same case is with &lt;c&gt; tag.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> print(sibling_soup.b.previous_sibling)\nNone\n>>> print(sibling_soup.c.next_sibling)\nNone\n﻿</code></pre>\n\n\n\n<p>The two strings are not siblings, as they don’t have the same parent.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> sibling_soup.b.string\n'Codemeals'\n>>>\n>>> print(sibling_soup.b.string.next_sibling)\nNone</code></pre>\n\n\n\n<h3>.next_siblings and .previous_siblings</h3>\n\n\n\n<p>To iterate over a tag’s siblings use .next_siblings and .previous_siblings.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> for sibling in soup.a.next_siblings:\nprint(repr(sibling))\n',\\n'\n&lt;a class=\"prog\" href=\"https://www.codemeals.com/cprogramming/index.htm\" id=\"link2\">C&lt;/a>\n',\\n'\n>a class=\"prog\" href=\"https://www.codemeals.com/python/index.htm\" id=\"link3\">Python&lt;/a>\n',\\n'\n&lt;a class=\"prog\" href=\"https://www.codemeals.com/javascript/javascript_overview.htm\" id=\"link4\">JavaScript&lt;/a>\n' and\\n'\n&lt;a class=\"prog\" href=\"https://www.codemeals.com/ruby/index.htm\"\nid=\"link5\">C&lt;/a>\n';\\n \\nas per online survey.'\n>>> for sibling in soup.find(id=\"link3\").previous_siblings:\nprint(repr(sibling))\n',\\n'\n&lt;a class=\"prog\" href=\"https://www.codemeals.com/cprogramming/index.htm\" id=\"link2\">C&lt;/a>\n',\\n'\n&lt;a class=\"prog\" href=\"https://www.codemeals.com/java/java_overview.htm\" id=\"link1\">Java&lt;/a>\n'Top 5 most used Programming Languages are: \\n'</code></pre>\n\n\n\n<h2>Going back and forth</h2>\n\n\n\n<p>Now let us get back to first two lines in our previous “html_doc” example −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;html>&lt;head>&lt;title>Tutorials Point&lt;/title>&lt;/head>\n&lt;body>\n&lt;h4 class=\"tagLine\">&lt;b>The Biggest Online Tutorials Library, It's all Free&lt;/b>&lt;/h4></code></pre>\n\n\n\n<p>An HTML parser takes above string of characters and turns it into a series of events like “open an &lt;html&gt; tag”, “open an &lt;head&gt; tag”, “open the &lt;title&gt; tag”, “add a string”, “close the &lt;/title&gt; tag”, “close the &lt;/head&gt; tag”, “open a &lt;h4&gt; tag” and so on. BeautifulSoup offers different methods to reconstructs the initial parse of the document.</p>\n\n\n\n<h3>.next_element and .previous_element</h3>\n\n\n\n<p>The .next_element attribute of a tag or string points to whatever was parsed immediately afterwards. Sometimes it looks similar to .next_sibling, however it is not same entirely. Below is the final &lt;a&gt; tag in our “html_doc” example document.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> last_a_tag = soup.find(\"a\", id=\"link5\")\n>>> last_a_tag\n&lt;a class=\"prog\" href=\"https://www.codemeals.com/ruby/index.htm\" id=\"link5\">C&lt;/a>\n>>> last_a_tag.next_sibling\n';\\n \\nas per online survey.'</code></pre>\n\n\n\n<p>However the .next_element of that &lt;a&gt; tag, the thing that was parsed immediately after the &lt;a&gt; tag, is not the rest of that sentence: it is the word “C”:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> last_a_tag.next_element\n'C'\n﻿</code></pre>\n\n\n\n<p>Above behavior is because in the original markup, the letter “C” appeared before that semicolon. The parser encountered an &lt;a&gt; tag, then the letter “C”, then the closing &lt;/a&gt; tag, then the semicolon and rest of the sentence. The semicolon is on the same level as the &lt;a&gt; tag, but the letter “C” was encountered first.</p>\n\n\n\n<p>The .previous_element attribute is the exact opposite of .next_element. It points to whatever element was parsed immediately before this one.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> last_a_tag.previous_element\n' and\\n'\n>>>\n>>> last_a_tag.previous_element.next_element\n&lt;a class=\"prog\" href=\"https://www.codemeals.com/ruby/index.htm\" id=\"link5\">C&lt;/a></code></pre>\n\n\n\n<h3>.next_elements and .previous_elements</h3>\n\n\n\n<p>We use these iterators to move forward and backward to an element.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> for element in last_a_tag.next_e lements:\nprint(repr(element))\n'C'\n';\\n \\nas per online survey.'\n'\\n'\n&lt;p class=\"prog\">Programming Languages&lt;/p>\n'Programming Languages'\n'\\n'\n﻿</code></pre>\n","protected":false},"excerpt":{"rendered":"<p>In this chapter, we shall discuss about Navigating by Tags. Below is our html document − Based on the above document, we will try to move from one part of document to another. Going down One of the important pieces of element in any piece of HTML document are tags, which may contain other tags/strings [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[31,56,129],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/61"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=61"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/61/revisions"}],"predecessor-version":[{"id":2978,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/61/revisions/2978"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=61"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=61"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=61"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":64,"date":"2020-06-30T08:16:19","date_gmt":"2020-06-30T08:16:19","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=64"},"modified":"2020-12-16T16:47:32","modified_gmt":"2020-12-16T16:47:32","slug":"searching-the-tree","status":"publish","type":"post","link":"https://python3.foobrdigital.com/searching-the-tree/","title":{"rendered":"Searching the Tree"},"content":{"rendered":"\n<p>There are many Beautifulsoup methods, which allows us to search a parse tree. The two most common and used methods are find() and find_all().</p>\n\n\n\n<p>Before talking about find() and find_all(), let us see some examples of different filters you can pass into these methods.</p>\n\n\n\n<h2>Kinds of Filters</h2>\n\n\n\n<p>We have different filters which we can pass into these methods and understanding of these filters is crucial as these filters used again and again, throughout the search API. We can use these filters based on tag’s name, on its attributes, on the text of a string, or mixed of these.</p>\n\n\n\n<h3>A string</h3>\n\n\n\n<p>One of the simplest types of filter is a string. Passing a string to the search method and Beautifulsoup will perform a match against that exact string.</p>\n\n\n\n<p>Below code will find all the &lt;p> tags in the document −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> markup = BeautifulSoup('&lt;p>Top Three&lt;/p>&lt;p>&lt;pre>Programming Languages are:&lt;/pre>&lt;/p>&lt;p>&lt;b>Java, Python, Cplusplus&lt;/b>&lt;/p>')\n>>> markup.find_all('p')\n&#91;&lt;p>Top Three&lt;/p>, &lt;p>&lt;/p>, &lt;p>&lt;b>Java, Python, Cplusplus&lt;/b>&lt;/p>]</code></pre>\n\n\n\n<h3>Regular Expression</h3>\n\n\n\n<p>You can find all tags starting with a given string/tag. Before that we need to import the re module to use regular expression.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> import re\n>>> markup = BeautifulSoup('&lt;p>Top Three&lt;/p>&lt;p>&lt;pre>Programming Languages are:&lt;/pre>&lt;/p>&lt;p>&lt;b>Java, Python, Cplusplus&lt;/b>&lt;/p>')\n>>>\n>>> markup.find_all(re.compile('^p'))\n&#91;&lt;p>Top Three&lt;/p>, &lt;p>&lt;/p>, &lt;pre>Programming Languages are:&lt;/pre>, &lt;p>&lt;b>Java, Python, Cplusplus&lt;/b>&lt;/p>]</code></pre>\n\n\n\n<h3>List</h3>\n\n\n\n<p>You can pass multiple tags to find by providing a list. Below code finds all the &lt;b> and &lt;pre> tags −</p>\n\n\n\n<pre class=\"wp-block-preformatted\">&gt;&gt;&gt; markup.find_all(['pre', 'b'])<br>[&lt;pre&gt;Programming Languages are:&lt;/pre&gt;, &lt;b&gt;Java, Python, Cplusplus&lt;/b&gt;]</pre>\n\n\n\n<h3>True</h3>\n\n\n\n<p>True will return all tags that it can find, but no strings on their own −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> markup.find_all(True)\n&#91;&lt;html>&lt;body>&lt;p>Top Three&lt;/p>&lt;p>&lt;/p>&lt;pre>Programming Languages are:&lt;/pre>\n&lt;p>&lt;b>Java, Python, Cplusplus&lt;/b> &lt;/p> &lt;/body>&lt;/html>, \n&lt;body>&lt;p>Top Three&lt;/p>&lt;p>&lt;/p>&lt;pre> Programming Languages are:&lt;/pre>&lt;p>&lt;b>Java, Python, Cplusplus&lt;/b>&lt;/p>\n&lt;/body>, \n&lt;p>Top Three&lt;/p>, &lt;p>&lt;/p>, &lt;pre>Programming Languages are:&lt;/pre>, &lt;p>&lt;b>Java, Python, Cplusplus&lt;/b>&lt;/p>, &lt;b>Java, Python, Cplusplus&lt;/b>]</code></pre>\n\n\n\n<p>To return only the tags from the above soup −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> for tag in markup.find_all(True):\n(tag.name)\n'html'\n'body'\n'p'\n'p'\n'pre'\n'p'\n'b'\n﻿</code></pre>\n\n\n\n<h2>find_all()</h2>\n\n\n\n<p>You can use find_all to extract all the occurrences of a particular tag from the page response as −</p>\n\n\n\n<h3>Syntax</h3>\n\n\n\n<pre class=\"wp-block-preformatted\">find_all(name, attrs, recursive, string, limit, **kwargs)\n</pre>\n\n\n\n<p>Let us extract some interesting data from IMDB-“Top rated movies” of all time.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> url=\"https://www.imdb.com/chart/top/?ref_=nv_mv_250\"\n>>> content = requests.get(url)\n>>> soup = BeautifulSoup(content.text, 'html.parser')\n#Extract title Page\n>>> print(soup.find('title'))\n&lt;title>IMDb Top 250 - IMDb&lt;/title>\n\n#Extracting main heading\n>>> for heading in soup.find_all('h1'):\n   print(heading.text)\nTop Rated Movies\n\n#Extracting sub-heading\n>>> for heading in soup.find_all('h3'):\n   print(heading.text)\n   \nIMDb Charts\nYou Have Seen\n   IMDb Charts\n   Top India Charts\nTop Rated Movies by Genre\nRecently Viewed</code></pre>\n\n\n\n<p>From above, we can see find_all will give us all the items matching the search criteria we define. All the filters we can use with find_all() can be used with find() and other searching methods too like find_parents() or find_siblings().</p>\n\n\n\n<h2>find()</h2>\n\n\n\n<p>We have seen above, find_all() is used to scan the entire document to find all the contents but something, the requirement is to find only one result. If you know that the document contains only one &lt;body&gt; tag, it is waste of time to search the entire document. One way is to call find_all() with limit=1 every time or else we can use find() method to do the same −</p>\n\n\n\n<h3>Syntax</h3>\n\n\n\n<pre class=\"wp-block-preformatted\">find(name, attrs, recursive, string, **kwargs)\n</pre>\n\n\n\n<p>So below two different methods gives the same output −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> soup.find_all('title',limit=1)\n&#91;&lt;title>IMDb Top 250 - IMDb&lt;/title>]\n>>>\n>>> soup.find('title')\n&lt;title>IMDb Top 250 - IMDb&lt;/title></code></pre>\n\n\n\n<p>In the above outputs, we can see the find_all() method returns a list containing single item whereas find() method returns single result.</p>\n\n\n\n<p>Another difference between find() and find_all() method is −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> soup.find_all('h2')\n&#91;]\n>>>\n>>> soup.find('h2')</code></pre>\n\n\n\n<p>If soup.find_all() method can’t find anything, it returns empty list whereas find() returns None.</p>\n\n\n\n<h2>find_parents() and find_parent()</h2>\n\n\n\n<p>Unlike the find_all() and find() methods which traverse the tree, looking at tag’s descendents, find_parents() and find_parents methods() do the opposite, they traverse the tree upwards and look at a tag’s (or a string’s) parents.</p>\n\n\n\n<h3>Syntax</h3>\n\n\n\n<pre class=\"wp-block-code\"><code>find_parents(name, attrs, string, limit, **kwargs)\nfind_parent(name, attrs, string, **kwargs)\n\n>>> a_string = soup.find(string=\"The Godfather\")\n>>> a_string\n'The Godfather'\n>>> a_string.find_parents('a')\n&#91;&lt;a href=\"/title/tt0068646/\" title=\"Francis Ford Coppola (dir.), Marlon Brando, Al Pacino\">The Godfather&lt;/a>]\n>>> a_string.find_parent('a')\n&lt;a href=\"/title/tt0068646/\" title=\"Francis Ford Coppola (dir.), Marlon Brando, Al Pacino\">The Godfather&lt;/a>\n>>> a_string.find_parent('tr')\n&lt;tr>\n\n&lt;td class=\"posterColumn\">\n&lt;span data-value=\"2\" name=\"rk\">&lt;/span>\n&lt;span data-value=\"9.149038526210072\" name=\"ir\">&lt;/span>\n&lt;span data-value=\"6.93792E10\" name=\"us\">&lt;/span>\n&lt;span data-value=\"1485540\" name=\"nv\">&lt;/span>\n&lt;span data-value=\"-1.850961473789928\" name=\"ur\">&lt;/span>\n&lt;a href=\"/title/tt0068646/\"> &lt;img alt=\"The Godfather\" height=\"67\" src=\"https://m.media-amazon.com/images/M/MV5BM2MyNjYxNmUtYTAwNi00MTYxLWJmNWYtYzZlODY3ZTk3OTFlXkEyXkFqcGdeQXVyNzkwMjQ5NzM@._V1_UY67_CR1,0,45,67_AL_.jpg\" width=\"45\"/>\n&lt;/a> &lt;/td>\n&lt;td class=\"titleColumn\">\n2.\n&lt;a href=\"/title/tt0068646/\" title=\"Francis Ford Coppola (dir.), Marlon Brando, Al Pacino\">The Godfather&lt;/a>\n&lt;span class=\"secondaryInfo\">(1972)&lt;/span>\n&lt;/td>\n&lt;td class=\"ratingColumn imdbRating\">\n&lt;strong title=\"9.1 based on 1,485,540 user ratings\">9.1&lt;/strong>\n&lt;/td>\n&lt;td class=\"ratingColumn\">\n&lt;div class=\"seen-widget seen-widget-tt0068646 pending\" data-titleid=\"tt0068646\">\n&lt;div class=\"boundary\">\n&lt;div class=\"popover\">\n&lt;span class=\"delete\"> &lt;/span>&lt;ol>&lt;li>1&lt;li>2&lt;li>3&lt;li>4&lt;li>5&lt;li>6&lt;li>7&lt;li>8&lt;li>9&lt;li>10&lt;/li>0&lt;/li>&lt;/li>&lt;/li>&lt;/li&amp;td;&lt;/li>&lt;/li>&lt;/li>&lt;/li>&lt;/li>&lt;/ol> &lt;/div>\n&lt;/div>\n&lt;div class=\"inline\">\n&lt;div class=\"pending\">&lt;/div>\n&lt;div class=\"unseeable\">NOT YET RELEASED&lt;/div>\n&lt;div class=\"unseen\"> &lt;/div>\n&lt;div class=\"rating\">&lt;/div>\n&lt;div class=\"seen\">Seen&lt;/div>\n&lt;/div>\n&lt;/div>\n&lt;/td>\n&lt;td class=\"watchlistColumn\">\n\n&lt;div class=\"wlb_ribbon\" data-recordmetrics=\"true\" data-tconst=\"tt0068646\">&lt;/div>\n&lt;/td>\n&lt;/tr>\n>>>\n>>> a_string.find_parents('td')\n&#91;&lt;td class=\"titleColumn\">\n2.\n&lt;a href=\"/title/tt0068646/\" title=\"Francis Ford Coppola (dir.), Marlon Brando, Al Pacino\">The Godfather&lt;/a>\n&lt;span class=\"secondaryInfo\">(1972)&lt;/span>\n&lt;/td>]</code></pre>\n\n\n\n<p>There are eight other similar methods −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>find_next_siblings(name, attrs, string, limit, **kwargs)\nfind_next_sibling(name, attrs, string, **kwargs)\n\nfind_previous_siblings(name, attrs, string, limit, **kwargs)\nfind_previous_sibling(name, attrs, string, **kwargs)\n\nfind_all_next(name, attrs, string, limit, **kwargs)\nfind_next(name, attrs, string, **kwargs)\n\nfind_all_previous(name, attrs, string, limit, **kwargs)\nfind_previous(name, attrs, string, **kwargs)</code></pre>\n\n\n\n<p>Where,</p>\n\n\n\n<p><strong>find_next_siblings()</strong>&nbsp;and&nbsp;<strong>find_next_sibling()</strong>&nbsp;methods will iterate over all the siblings of the element that come after the current one.</p>\n\n\n\n<p><strong>find_previous_siblings()</strong>&nbsp;and&nbsp;<strong>find_previous_sibling()</strong>&nbsp;methods will iterate over all the siblings that come before the current element.</p>\n\n\n\n<p><strong>find_all_next()</strong>&nbsp;and&nbsp;<strong>find_next()</strong>&nbsp;methods will iterate over all the tags and strings that come after the current element.</p>\n\n\n\n<p><strong>find_all_previous</strong>&nbsp;and&nbsp;<strong>find_previous()</strong>&nbsp;methods will iterate over all the tags and strings that come before the current element.</p>\n\n\n\n<h2>CSS selectors</h2>\n\n\n\n<p>The BeautifulSoup library to support the most commonly-used CSS selectors. You can search for elements using CSS selectors with the help of the select() method.</p>\n\n\n\n<p>Here are some examples −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> soup.select('title')\n&#91;&lt;title>IMDb Top 250 - IMDb&lt;/title>, &lt;title>IMDb Top Rated Movies&lt;/title>]\n>>>\n>>> soup.select(\"p:nth-of-type(1)\")\n&#91;&lt;p>The Top Rated Movie list only includes theatrical features.&lt;/p>, &lt;p> class=\"imdb-footer__copyright _2-iNNCFskmr4l2OFN2DRsf\">© 1990-2019 by IMDb.com, Inc.&lt;/p>]\n>>> len(soup.select(\"p:nth-of-type(1)\"))\n2\n>>> len(soup.select(\"a\"))\n609\n>>> len(soup.select(\"p\"))\n2\n\n>>> soup.select(\"html head title\")\n&#91;&lt;title>IMDb Top 250 - IMDb&lt;/title>, &lt;title>IMDb Top Rated Movies&lt;/title>]\n>>> soup.select(\"head > title\")\n&#91;&lt;title>IMDb Top 250 - IMDb&lt;/title>]\n\n#print HTML code of the tenth li elemnet\n>>> soup.select(\"li:nth-of-type(10)\")\n&#91;&lt;li class=\"subnav_item_main\">\n&lt;a href=\"/search/title?genres=film_noir&amp;sort=user_rating,desc&amp;title_type=feature&amp;num_votes=25000,\">Film-Noir\n&lt;/a> &lt;/li>]</code></pre>\n","protected":false},"excerpt":{"rendered":"<p>There are many Beautifulsoup methods, which allows us to search a parse tree. The two most common and used methods are find() and find_all(). Before talking about find() and find_all(), let us see some examples of different filters you can pass into these methods. Kinds of Filters We have different filters which we can pass [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[31,56,129],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/64"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=64"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/64/revisions"}],"predecessor-version":[{"id":2977,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/64/revisions/2977"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=64"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=64"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=64"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":66,"date":"2020-06-30T08:21:13","date_gmt":"2020-06-30T08:21:13","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=66"},"modified":"2020-12-16T16:47:32","modified_gmt":"2020-12-16T16:47:32","slug":"modifying-the-tree","status":"publish","type":"post","link":"https://python3.foobrdigital.com/modifying-the-tree/","title":{"rendered":"Modifying the Tree"},"content":{"rendered":"\n<p>One of the important aspects of BeautifulSoup is search the parse tree and it allows you to make changes to the web document according to your requirement. We can make changes to tag’s properties using its attributes, such as the .name, .string or .append() method. It allows you to add new tags and strings to an existing tag with the help of the .new_string() and .new_tag() methods. There are other methods too, such as .insert(), .insert_before() or .insert_after() to make various modification to your HTML or XML document.</p>\n\n\n\n<h2>Changing tag names and attributes</h2>\n\n\n\n<p>Once you have created the soup, it is easy to make modification like renaming the tag, make modification to its attributes, add new attributes and delete attributes.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> soup = BeautifulSoup('&lt;b class=\"bolder\">Very Bold&lt;/b>')\n>>> tag = soup.b</code></pre>\n\n\n\n<p>Modification and adding new attributes are as follows −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> tag.name = 'Blockquote'\n>>> tag&#91;'class'] = 'Bolder'\n>>> tag&#91;'id'] = 1.1\n>>> tag\n&lt;Blockquote class=\"Bolder\" id=\"1.1\">Very Bold&lt;/Blockquote></code></pre>\n\n\n\n<p>Deleting attributes are as follows −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> del tag&#91;'class']\n>>> tag\n&lt;Blockquote id=\"1.1\">Very Bold&lt;/Blockquote>\n>>> del tag&#91;'id']\n>>> tag\n&lt;Blockquote>Very Bold&lt;/Blockquote></code></pre>\n\n\n\n<h2>Modifying .string</h2>\n\n\n\n<p>You can easily modify the tag’s .string attribute −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> markup = '&lt;a href=\"https://www.codemeals.com/index.htm\">Must for every &lt;i>Learner>/i&lt;&lt;/a>'\n>>> Bsoup = BeautifulSoup(markup)\n>>> tag = Bsoup.a\n>>> tag.string = \"My Favourite spot.\"\n>>> tag\n&lt;a href=\"https://www.codemeals.com/index.htm\">My Favourite spot.&lt;/a>\n﻿</code></pre>\n\n\n\n<p>From above, we can see if the tag contains any other tag, they and all their contents will be replaced by new data.</p>\n\n\n\n<h2>append()</h2>\n\n\n\n<p>Adding new data/contents to an existing tag is by using tag.append() method. It is very much similar to append() method in Python list.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> markup = '&lt;a href=\"https://www.codemeals.com/index.htm\">Must for every &lt;i>Learner&lt;/i>&lt;/a>'\n>>> Bsoup = BeautifulSoup(markup)\n>>> Bsoup.a.append(\" Really Liked it\")\n>>> Bsoup\n&lt;html>&lt;body>&lt;a href=\"https://www.codemeals.com/index.htm\">Must for every &lt;i>Learner&lt;/i> Really Liked it&lt;/a>&lt;/body>&lt;/html>\n>>> Bsoup.a.contents\n&#91;'Must for every ', &lt;i>Learner&lt;/i>, ' Really Liked it']</code></pre>\n\n\n\n<h2>NavigableString() and .new_tag()</h2>\n\n\n\n<p>In case you want to add a string to a document, this can be done easily by using the append() or by NavigableString() constructor −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> soup = BeautifulSoup(\"&lt;b>&lt;/b>\")\n>>> tag = soup.b\n>>> tag.append(\"Start\")\n>>>\n>>> new_string = NavigableString(\" Your\")\n>>> tag.append(new_string)\n>>> tag\n&lt;b>Start Your&lt;/b>\n>>> tag.contents\n&#91;'Start', ' Your']</code></pre>\n\n\n\n<p><strong>Note:</strong>&nbsp;If you find any name Error while accessing the NavigableString() function, as follows−</p>\n\n\n\n<p><em>NameError: name &#8216;NavigableString&#8217; is not defined</em></p>\n\n\n\n<p>Just import the NavigableString directory from bs4 package −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> from bs4 import NavigableString\n﻿</code></pre>\n\n\n\n<p>We can resolve the above error.</p>\n\n\n\n<p>You can add comments to your existing tag’s or can add some other subclass of NavigableString, just call the constructor.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> from bs4 import Comment\n>>> adding_comment = Comment(\"Always Learn something Good!\")\n>>> tag.append(adding_comment)\n>>> tag\n&lt;b>Start Your&lt;!--Always Learn something Good!-->&lt;/b>\n>>> tag.contents\n&#91;'Start', ' Your', 'Always Learn something Good!']</code></pre>\n\n\n\n<p>Adding a whole new tag (not appending to an existing tag) can be done using the Beautifulsoup inbuilt method, BeautifulSoup.new_tag() −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> soup = BeautifulSoup(\"&lt;b>&lt;/b>\")\n>>> Otag = soup.b\n>>>\n>>> Newtag = soup.new_tag(\"a\", href=\"https://www.codemeals.com\")\n>>> Otag.append(Newtag)\n>>> Otag\n&lt;b>&lt;a href=\"https://www.codemeals.com\">&lt;/a>&lt;/b></code></pre>\n\n\n\n<p>Only the first argument, the tag name, is required.</p>\n\n\n\n<h2>insert()</h2>\n\n\n\n<p>Similar to .insert() method on python list, tag.insert() will insert new element however, unlike tag.append(), new element doesn’t necessarily go at the end of its parent’s contents. New element can be added at any position.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> markup = '&lt;a href=\"https://www.djangoproject.com/community/\">Django Official website &lt;i>Huge Community base&lt;/i>&lt;/a>'\n>>> soup = BeautifulSoup(markup)\n>>> tag = soup.a\n>>>\n>>> tag.insert(1, \"Love this framework \")\n>>> tag\n&lt;a href=\"https://www.djangoproject.com/community/\">Django Official website Love this framework &lt;i>Huge Community base&lt;/i>&lt;/a>\n>>> tag.contents\n&#91;'Django Official website ', 'Love this framework ', &lt;i>Huge Community base&lt;/i\n>]\n>>></code></pre>\n\n\n\n<h2>insert_before() and insert_after()</h2>\n\n\n\n<p>To insert some tag or string just before something in the parse tree, we use insert_before() −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> soup = BeautifulSoup(\"Brave\")\n>>> tag = soup.new_tag(\"i\")\n>>> tag.string = \"Be\"\n>>>\n>>> soup.b.string.insert_before(tag)\n>>> soup.b\n&lt;b>&lt;i>Be&lt;/i>Brave&lt;/b></code></pre>\n\n\n\n<p>Similarly to insert some tag or string just after something in the parse tree, use insert_after().</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> soup.b.i.insert_after(soup.new_string(\" Always \"))\n>>> soup.b\n&lt;b>&lt;i>Be&lt;/i> Always Brave&lt;/b>\n>>> soup.b.contents\n&#91;&lt;i>Be&lt;/i>, ' Always ', 'Brave']</code></pre>\n\n\n\n<h2>clear()</h2>\n\n\n\n<p>To remove the contents of a tag, use tag.clear() −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> markup = '&lt;a href=\"https://www.codemeals.com/index.htm\">For &lt;i>technical &amp; Non-technical&amp;lr;/i> Contents&lt;/a>'\n>>> soup = BeautifulSoup(markup)\n>>> tag = soup.a\n>>> tag\n&lt;a href=\"https://www.codemeals.com/index.htm\">For &lt;i>technical &amp; Non-technical&lt;/i> Contents&lt;/a>\n>>>\n>>> tag.clear()\n>>> tag\n&lt;a href=\"https://www.codemeals.com/index.htm\">&lt;/a></code></pre>\n\n\n\n<h2>extract()</h2>\n\n\n\n<p>To remove a tag or strings from the tree, use PageElement.extract().</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> markup = '&lt;a href=\"https://www.codemeals.com/index.htm\">For &lt;i&amp;gr;technical &amp; Non-technical&lt;/i> Contents&lt;/a>'\n>>> soup = BeautifulSoup(markup)\n>>> a_tag = soup.a\n>>>\n>>> i_tag = soup.i.extract()\n>>>\n>>> a_tag\n&lt;a href=\"https://www.codemeals.com/index.htm\">For Contents&lt;/a>\n>>>\n>>> i_tag\n&lt;i>technical &amp; Non-technical&lt;/i>\n>>>\n>>> print(i_tag.parent)\nNone</code></pre>\n\n\n\n<h2>decompose()</h2>\n\n\n\n<p>The tag.decompose() removes a tag from the tree and deletes all its contents.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> markup = '&lt;a href=\"https://www.codemeals.com/index.htm\">For &lt;i>technical &amp; Non-technical&lt;/i> Contents&lt;/a>'\n>>> soup = BeautifulSoup(markup)\n>>> a_tag = soup.a\n>>> a_tag\n&lt;a href=\"https://www.codemeals.com/index.htm\">For &lt;i>technical &amp; Non-technical&lt;/i> Contents&lt;/a>\n>>>\n>>> soup.i.decompose()\n>>> a_tag\n&lt;a href=\"https://www.codemeals.com/index.htm\">For Contents&lt;/a>\n>>></code></pre>\n\n\n\n<h2>Replace_with()</h2>\n\n\n\n<p>As the name suggests, pageElement.replace_with() function will replace the old tag or string with the new tag or string in the tree −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> markup = '&lt;a href=\"https://www.codemeals.com/index.htm\">Complete Python &lt;i>Material&lt;/i>&lt;/a>'\n>>> soup = BeautifulSoup(markup)\n>>> a_tag = soup.a\n>>>\n>>> new_tag = soup.new_tag(\"Official_site\")\n>>> new_tag.string = \"https://www.python.org/\"\n>>> a_tag.i.replace_with(new_tag)\n&lt;i>Material&lt;/i>\n>>>\n>>> a_tag\n&lt;a href=\"https://www.codemeals.com/index.htm\">Complete Python &lt;Official_site>https://www.python.org/&lt;/Official_site>&lt;/a></code></pre>\n\n\n\n<p>In the above output, you have noticed that replace_with() returns the tag or string that was replaced (like “Material” in our case), so you can examine it or add it back to another part of the tree.</p>\n\n\n\n<h2>wrap()</h2>\n\n\n\n<p>The pageElement.wrap() enclosed an element in the tag you specify and returns a new wrapper −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> soup = BeautifulSoup(\"&lt;p>codemeals.com&lt;/p>\")\n>>> soup.p.string.wrap(soup.new_tag(\"b\"))\n&lt;b>codemeals.com&lt;/b>\n>>>\n>>> soup.p.wrap(soup.new_tag(\"Div\"))\n&lt;Div>&lt;p>&lt;b>codemeals.com&lt;/b>&lt;/p>&lt;/Div></code></pre>\n\n\n\n<h2>unwrap()</h2>\n\n\n\n<p>The tag.unwrap() is just opposite to wrap() and replaces a tag with whatever inside that tag.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> soup = BeautifulSoup('&lt;a href=\"https://www.codemeals.com/\">I liked &lt;i>codemeals&lt;/i>&lt;/a>')\n>>> a_tag = soup.a\n>>>\n>>> a_tag.i.unwrap()\n&lt;i>&lt;/i>\n>>> a_tag\n&lt;a href=\"https://www.codemeals.com/\">I liked codemeals&lt;/a></code></pre>\n\n\n\n<p>From above, you have noticed that like replace_with(), unwrap() returns the tag that was replaced.</p>\n\n\n\n<p>Below is one more example of unwrap() to understand it better −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> soup = BeautifulSoup(\"&lt;p>I &lt;strong>AM&lt;/strong> a &lt;i>text&lt;/i>.&lt;/p>\")\n>>> soup.i.unwrap()\n&lt;i>&lt;/i>\n>>> soup\n&lt;html>&lt;body>&lt;p>I &lt;strong>AM&lt;/strong> a text.&lt;/p>&lt;/body>&lt;/html></code></pre>\n\n\n\n<p>unwrap() is good for striping out markup.</p>\n","protected":false},"excerpt":{"rendered":"<p>One of the important aspects of BeautifulSoup is search the parse tree and it allows you to make changes to the web document according to your requirement. We can make changes to tag’s properties using its attributes, such as the .name, .string or .append() method. It allows you to add new tags and strings to [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[31,56,129],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/66"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=66"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/66/revisions"}],"predecessor-version":[{"id":2976,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/66/revisions/2976"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=66"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=66"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=66"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":68,"date":"2020-06-30T08:25:48","date_gmt":"2020-06-30T08:25:48","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=68"},"modified":"2020-12-16T16:47:32","modified_gmt":"2020-12-16T16:47:32","slug":"encoding","status":"publish","type":"post","link":"https://python3.foobrdigital.com/encoding/","title":{"rendered":"Encoding"},"content":{"rendered":"\n<p>All HTML or XML documents are written in some specific encoding like ASCII or UTF-8. However, when you load that HTML/XML document into BeautifulSoup, it has been converted to Unicode.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> markup = \"&lt;p>I will display £&lt;/p>\"\n>>> Bsoup = BeautifulSoup(markup)\n>>> Bsoup.p\n&lt;p>I will display £&lt;/p>\n>>> Bsoup.p.string\n'I will display £'</code></pre>\n\n\n\n<p>Above behavior is because BeautifulSoup internally uses the sub-library called Unicode, Dammit to detect a document’s encoding and then convert it into Unicode.</p>\n\n\n\n<p>However, not all the time, the Unicode, Dammit guesses correctly. As the document is searched byte-by-byte to guess the encoding, it takes lot of time. You can save some time and avoid mistakes, if you already know the encoding by passing it to the BeautifulSoup constructor as from_encoding.</p>\n\n\n\n<p>Below is one example where the BeautifulSoup misidentifies, an ISO-8859-8 document as ISO-8859-7 −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> markup = b\"&lt;h1>\\xed\\xe5\\xec\\xf9&lt;/h1>\"\n>>> soup = BeautifulSoup(markup)\n>>> soup.h1\n&lt;h1>νεμω&lt;/h1>\n>>> soup.original_encoding\n'ISO-8859-7'\n>>></code></pre>\n\n\n\n<p>To resolve above issue, pass it to BeautifulSoup using from_encoding −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> soup = BeautifulSoup(markup, from_encoding=\"iso-8859-8\")\n>>> soup.h1\n&lt;h1>ולש &lt;/h1>\n>>> soup.original_encoding\n'iso-8859-8'\n>>></code></pre>\n\n\n\n<p>Another new feature added from BeautifulSoup 4.4.0 is, exclude_encoding. It can be used, when you don’t know the correct encoding but sure that Unicode, Dammit is showing wrong result.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> soup = BeautifulSoup(markup, exclude_encodings=&#91;\"ISO-8859-7\"])\n﻿</code></pre>\n\n\n\n<h2>Output encoding</h2>\n\n\n\n<p>The output from a BeautifulSoup is UTF-8 document, irrespective of the entered document to BeautifulSoup. Below a document, where the polish characters are there in ISO-8859-2 format.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>html_markup = \"\"\"\n&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n&lt;HTML>\n&lt;HEAD>\n&lt;META HTTP-EQUIV=\"content-type\" CONTENT=\"text/html; charset=iso-8859-2\">\n&lt;/HEAD>\n&lt;BODY>\ną ć ę ł ń ó ś ź ż Ą Ć Ę Ł Ń Ó Ś Ź Ż\n&lt;/BODY>\n&lt;/HTML>\n\"\"\"\n\n\n>>> soup = BeautifulSoup(html_markup)\n>>> print(soup.prettify())\n&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n&lt;html>\n   &lt;head>\n      &lt;meta content=\"text/html; charset=utf-8\" http-equiv=\"content-type\"/>\n   &lt;/head>\n   &lt;body>\n      ą ć ę ł ń ó ś ź ż Ą Ć Ę Ł Ń Ó Ś Ź Ż\n   &lt;/body>\n&lt;/html></code></pre>\n\n\n\n<p>In the above example, if you notice, the &lt;meta&gt; tag has been rewritten to reflect the generated document from BeautifulSoup is now in UTF-8 format.</p>\n\n\n\n<p>If you don’t want the generated output in UTF-8, you can assign the desired encoding in prettify().</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> print(soup.prettify(\"latin-1\"))\nb'&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\\n&lt;html>\\n &lt;head>\\n &lt;meta content=\"text/html; charset=latin-1\" http-equiv=\"content-type\"/>\\n &lt;/head>\\n &lt;body>\\n ą ć ę ł ń \\xf3 ś ź ż Ą Ć Ę Ł Ń \\xd3 Ś Ź Ż\\n &lt;/body>\\n&lt;/html>\\n'</code></pre>\n\n\n\n<p>In the above example, we have encoded the complete document, however you can encode, any particular element in the soup as if they were a python string −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> soup.p.encode(\"latin-1\")\nb'&lt;p>0My first paragraph.&lt;/p>'\n>>> soup.h1.encode(\"latin-1\")\nb'&lt;h1>My First Heading&lt;/h1>'</code></pre>\n\n\n\n<p>Any characters that can’t be represented in your chosen encoding will be converted into numeric XML entity references. Below is one such example −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> markup = u\"&lt;b>\\N{SNOWMAN}&lt;/b>\"\n>>> snowman_soup = BeautifulSoup(markup)\n>>> tag = snowman_soup.b\n>>> print(tag.encode(\"utf-8\"))\nb'&lt;b>\\xe2\\x98\\x83&lt;/b>'</code></pre>\n\n\n\n<p>If you try to encode the above in “latin-1” or “ascii”, it will generate “☃”, indicating there is no representation for that.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> print (tag.encode(\"latin-1\"))\nb'&lt;b>☃&lt;/b>'\n>>> print (tag.encode(\"ascii\"))\nb'&lt;b>☃&lt;/b>'</code></pre>\n\n\n\n<h2>Unicode, Dammit</h2>\n\n\n\n<p>Unicode, Dammit is used mainly when the incoming document is in unknown format (mainly foreign language) and we want to encode in some known format (Unicode) and also we don’t need Beautifulsoup to do all this.</p>\n","protected":false},"excerpt":{"rendered":"<p>All HTML or XML documents are written in some specific encoding like ASCII or UTF-8. However, when you load that HTML/XML document into BeautifulSoup, it has been converted to Unicode. Above behavior is because BeautifulSoup internally uses the sub-library called Unicode, Dammit to detect a document’s encoding and then convert it into Unicode. However, not [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[31,56,129],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/68"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=68"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/68/revisions"}],"predecessor-version":[{"id":2975,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/68/revisions/2975"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=68"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=68"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=68"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":71,"date":"2020-06-30T09:52:03","date_gmt":"2020-06-30T09:52:03","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=71"},"modified":"2020-12-16T16:47:32","modified_gmt":"2020-12-16T16:47:32","slug":"beautiful-objects","status":"publish","type":"post","link":"https://python3.foobrdigital.com/beautiful-objects/","title":{"rendered":"Beautiful Objects"},"content":{"rendered":"\n<p>The starting point of any BeautifulSoup project, is the BeautifulSoup object. A BeautifulSoup object represents the input HTML/XML document used for its creation.</p>\n\n\n\n<p>We can either pass a string or a file-like object for Beautiful Soup, where files (objects) are either locally stored in our machine or a web page.</p>\n\n\n\n<p>The most common BeautifulSoup Objects are −</p>\n\n\n\n<ul><li>Tag</li><li>NavigableString</li><li>BeautifulSoup</li><li>Comment</li></ul>\n\n\n\n<h2>Comparing objects for equality</h2>\n\n\n\n<p>As per the beautiful soup, two navigable string or tag objects are equal if they represent the same HTML/XML markup.</p>\n\n\n\n<p>Now let us see the below example, where the two &lt;b&gt; tags are treated as equal, even though they live in different parts of the object tree, because they both look like “&lt;b&gt;Java&lt;/b&gt;”.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> markup = \"&lt;p>Learn Python and &lt;b>Java&lt;/b> and advanced &lt;b>Java&lt;/b>! from Codemeals&lt;/p>\"\n>>> soup = BeautifulSoup(markup, \"html.parser\")\n>>> first_b, second_b = soup.find_all('b')\n>>> print(first_b == second_b)\nTrue\n>>> print(first_b.previous_element == second_b.previous_element)\nFalse</code></pre>\n\n\n\n<p>However, to check if the two variables refer to the same objects, you can use the following−</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> print(first_b is second_b)\nFalse\n﻿</code></pre>\n\n\n\n<h2>Copying Beautiful Soup objects</h2>\n\n\n\n<p>To create a copy of any tag or NavigableString, use copy.copy() function, just like below −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> import copy\n>>> p_copy = copy.copy(soup.p)\n>>> print(p_copy)\n&lt;p>Learn Python and &lt;b>Java&lt;/b> and advanced &lt;b>Java&lt;/b>! from Codemeals&lt;/p>\n>>></code></pre>\n\n\n\n<p>Although the two copies (original and copied one) contain the same markup however, the two do not represent the same object −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> print(soup.p == p_copy)\nTrue\n>>>\n>>> print(soup.p is p_copy)\nFalse\n>>></code></pre>\n\n\n\n<p>The only real difference is that the copy is completely detached from the original Beautiful Soup object tree, just as if extract() had been called on it.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> print(p_copy.parent)\nNone\n﻿</code></pre>\n\n\n\n<p>Above behavior is due to two different tag objects which cannot occupy the same space at the same time.</p>\n","protected":false},"excerpt":{"rendered":"<p>The starting point of any BeautifulSoup project, is the BeautifulSoup object. A BeautifulSoup object represents the input HTML/XML document used for its creation. We can either pass a string or a file-like object for Beautiful Soup, where files (objects) are either locally stored in our machine or a web page. The most common BeautifulSoup Objects [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[31,56,129],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/71"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=71"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/71/revisions"}],"predecessor-version":[{"id":2974,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/71/revisions/2974"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=71"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=71"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=71"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":73,"date":"2020-06-30T09:53:28","date_gmt":"2020-06-30T09:53:28","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=73"},"modified":"2020-12-16T16:47:32","modified_gmt":"2020-12-16T16:47:32","slug":"parsing-only-section-of-a-document","status":"publish","type":"post","link":"https://python3.foobrdigital.com/parsing-only-section-of-a-document/","title":{"rendered":"Parsing only section of a document"},"content":{"rendered":"\n<p>There are multiple situations where you want to extract specific types of information (only &lt;a&gt; tags) using Beautifulsoup4. The SoupStrainer class in Beautifulsoup allows you to parse only specific part of an incoming document.</p>\n\n\n\n<p>One way is to create a SoupStrainer and pass it on to the Beautifulsoup4 constructor as the parse_only argument.</p>\n\n\n\n<h2>SoupStrainer</h2>\n\n\n\n<p>A SoupStrainer tells BeautifulSoup what parts extract, and the parse tree consists of only these elements. If you narrow down your required information to a specific portion of the HTML, this will speed up your search result.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>product = SoupStrainer('div',{'id': 'products_list'})\nsoup = BeautifulSoup(html,parse_only=product)</code></pre>\n\n\n\n<p>Above lines of code will parse only the titles from a product site, which might be inside a tag field.</p>\n\n\n\n<p>Similarly, like above we can use other soupStrainer objects, to parse specific information from an HTML tag. Below are some of the examples −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from bs4 import BeautifulSoup, SoupStrainer\n\n#Only \"a\" tags\nonly_a_tags = SoupStrainer(\"a\")\n\n#Will parse only the below mentioned \"ids\".\nparse_only = SoupStrainer(id=&#91;\"first\", \"third\", \"my_unique_id\"])\nsoup = BeautifulSoup(my_document, \"html.parser\", parse_only=parse_only)\n\n#parse only where string length is less than 10\ndef is_short_string(string):\n   return len(string) &lt; 10\n   \nonly_short_strings =SoupStrainer(string=is_short_string)</code></pre>\n","protected":false},"excerpt":{"rendered":"<p>There are multiple situations where you want to extract specific types of information (only &lt;a&gt; tags) using Beautifulsoup4. The SoupStrainer class in Beautifulsoup allows you to parse only specific part of an incoming document. One way is to create a SoupStrainer and pass it on to the Beautifulsoup4 constructor as the parse_only argument. SoupStrainer A [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[31,56,129],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/73"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=73"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/73/revisions"}],"predecessor-version":[{"id":2973,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/73/revisions/2973"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=73"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=73"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=73"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":79,"date":"2020-06-30T09:56:35","date_gmt":"2020-06-30T09:56:35","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=79"},"modified":"2020-12-16T16:47:32","modified_gmt":"2020-12-16T16:47:32","slug":"trouble-shooting","status":"publish","type":"post","link":"https://python3.foobrdigital.com/trouble-shooting/","title":{"rendered":"Trouble Shooting"},"content":{"rendered":"\n<h2>Error Handling</h2>\n\n\n\n<p>There are two main kinds of errors that need to be handled in BeautifulSoup. These two errors are not from your script but from the structure of the snippet because the BeautifulSoup API throws an error.</p>\n\n\n\n<p>The two main errors are as follows −</p>\n\n\n\n<h3>AttributeError</h3>\n\n\n\n<p>It is caused when the dot notation doesn’t find a sibling tag to the current HTML tag. For example, you may have encountered this error, because of missing “anchor tag”, cost-key will throw an error as it traverses and requires an anchor tag.</p>\n\n\n\n<h3>KeyError</h3>\n\n\n\n<p>This error occurs if the required HTML tag attribute is missing. For example, if we don’t have data-pid attribute in a snippet, the pid key will throw key-error.</p>\n\n\n\n<p>To avoid the above two listed errors when parsing a result, that result will be bypassed to make sure that a malformed snippet isn’t inserted into the databases −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>except(AttributeError, KeyError) as er:\npass\n﻿</code></pre>\n\n\n\n<h2>diagnose()</h2>\n\n\n\n<p>Whenever we find any difficulty in understanding what BeautifulSoup does to our document or HTML, simply pass it to the diagnose() function. On passing document file to the diagnose() function, we can show how list of different parser handles the document.</p>\n\n\n\n<p>Below is one example to demonstrate the use of diagnose() function −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from bs4.diagnose import diagnose\n\nwith open(\"20 Books.html\",encoding=\"utf8\") as fp:\n   data = fp.read()\n   \ndiagnose(data)</code></pre>\n\n\n\n<h3>Output</h3>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/beautiful_soup/images/diagnose.jpg\" alt=\"Diagnose\"/></figure>\n\n\n\n<h2>Parsing error</h2>\n\n\n\n<p>There are two main types of parsing errors. You might get an exception like HTMLParseError, when you feed your document to BeautifulSoup. You may also get an unexpected result, where the BeautifulSoup parse tree looks a lot different from the expected result from the parse document.</p>\n\n\n\n<p>None of the parsing error is caused due to BeautifulSoup. It is because of external parser we use (html5lib, lxml) since BeautifulSoup doesn’t contain any parser code. One way to resolve above parsing error is to use another parser.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from HTMLParser import HTMLParser\n\ntry:\n   from HTMLParser import HTMLParseError\nexcept ImportError, e:\n   # From python 3.5, HTMLParseError is removed. Since it can never be\n   # thrown in 3.5, we can just define our own class as a placeholder.\n   class HTMLParseError(Exception):\n      pass</code></pre>\n\n\n\n<p>Python built-in HTML parser causes two most common parse errors, HTMLParser.HTMLParserError: malformed start tag and HTMLParser.HTMLParserError: bad end tag and to resolve this, is to use another parser mainly: lxml or html5lib.</p>\n\n\n\n<p>Another common type of unexpected behavior is that you can’t find a tag that you know is in the document. However, when you run the find_all() returns [] or find() returns None.</p>\n\n\n\n<p>This may be due to python built-in HTML parser sometimes skips tags it doesn’t understand.</p>\n\n\n\n<h2>XML parser Error</h2>\n\n\n\n<p>By default, BeautifulSoup package parses the documents as HTML, however, it is very easy-to-use and handle ill-formed XML in a very elegant manner using beautifulsoup4.</p>\n\n\n\n<p>To parse the document as XML, you need to have lxml parser and you just need to pass the “xml” as the second argument to the Beautifulsoup constructor −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>soup = BeautifulSoup(markup, \"lxml-xml\")</code></pre>\n\n\n\n<p>or</p>\n\n\n\n<pre class=\"wp-block-code\"><code>soup = BeautifulSoup(markup, \"xml\")\n</code></pre>\n\n\n\n<p>One common XML parsing error is −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>AttributeError: 'NoneType' object has no attribute 'attrib'\n</code></pre>\n\n\n\n<p>This might happen in case, some element is missing or not defined while using find() or findall() function.</p>\n\n\n\n<h2>Other parsing errors</h2>\n\n\n\n<p>Given below are some of the other parsing errors we are going to discuss in this section −</p>\n\n\n\n<h3>Environmental issue</h3>\n\n\n\n<p>Apart from the above mentioned parsing errors, you may encounter other parsing issues such as environmental issues where your script might work in one operating system but not in another operating system or may work in one virtual environment but not in another virtual environment or may not work outside the virtual environment. All these issues may be because the two environments have different parser libraries available.</p>\n\n\n\n<p>It is recommended to know or check your default parser in your current working environment. You can check the current default parser available for the current working environment or else pass explicitly the required parser library as second arguments to the BeautifulSoup constructor.</p>\n\n\n\n<h3>Case-insensitive</h3>\n\n\n\n<p>As the HTML tags and attributes are case-insensitive, all three HTML parsers convert tag and attribute names to lowercase. However, if you want to preserve mixed-case or uppercase tags and attributes, then it is better to parse the document as XML.</p>\n\n\n\n<h3>UnicodeEncodeError</h3>\n\n\n\n<p>Let us look into below code segment −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>soup = BeautifulSoup(response, \"html.parser\")\n   print (soup)\n﻿</code></pre>\n\n\n\n<h3>Output</h3>\n\n\n\n<pre class=\"wp-block-code\"><code>UnicodeEncodeError: 'charmap' codec can't encode character '\\u011f'</code></pre>\n\n\n\n<p>Above problem may be because of two main situations. You might be trying to print out a unicode character that your console doesn’t know how to display. Second, you are trying to write to a file and you pass in a Unicode character that’s not supported by your default encoding.</p>\n\n\n\n<p>One way to resolve above problem is to encode the response text/character before making the soup to get the desired result, as follows −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>responseTxt = response.text.encode('UTF-8')</code></pre>\n\n\n\n<h2>KeyError: [attr]</h2>\n\n\n\n<p>It is caused by accessing tag[‘attr’] when the tag in question doesn’t define the attr attribute. Most common errors are: “KeyError: ‘href’” and “KeyError: ‘class’”. Use tag.get(‘attr’) if you are not sure attr is defined.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>for item in soup.fetch('a'):\n   try:\n      if (item&#91;'href'].startswith('/') or \"codemeals\" in item&#91;'href']):\n      (...)\n   except KeyError:\n      pass # or some other fallback action</code></pre>\n\n\n\n<h3>AttributeError</h3>\n\n\n\n<p>You may encounter AttributeError as follows −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>AttributeError: 'list' object has no attribute 'find_all'</code></pre>\n\n\n\n<p>The above error mainly occurs because you expected find_all() return a single tag or string. However, soup.find_all returns a python list of elements.</p>\n\n\n\n<p>All you need to do is to iterate through the list and catch data from those elements.</p>\n","protected":false},"excerpt":{"rendered":"<p>Error Handling There are two main kinds of errors that need to be handled in BeautifulSoup. These two errors are not from your script but from the structure of the snippet because the BeautifulSoup API throws an error. The two main errors are as follows − AttributeError It is caused when the dot notation doesn’t [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[31,56,129],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/79"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=79"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/79/revisions"}],"predecessor-version":[{"id":2972,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/79/revisions/2972"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=79"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=79"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=79"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}}]