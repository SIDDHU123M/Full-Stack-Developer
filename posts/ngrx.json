[{"id":2495,"date":"2020-09-07T15:47:54","date_gmt":"2020-09-07T15:47:54","guid":{"rendered":"http://angular.foobrdigital.com/?p=2495"},"modified":"2020-12-25T19:06:26","modified_gmt":"2020-12-25T19:06:26","slug":"introduction-10","status":"publish","type":"post","link":"https://angular.foobrdigital.com/introduction-10/","title":{"rendered":"Introduction"},"content":{"rendered":"\n<p>Some components must have state. When there is a need for another component to know about that very same state, the first component needs to find a way to communicate that to the other component. There are many ways to achieve this. One way is to ensure that all state that should be shared lives in a centralized store. Think of this store as a single source of truth, from which all components can read. Every state does not necessarily need to end up in the centralized store, as the state may only concern a specific component.</p>\n\n\n\n<p>Before NgRx and Redux, one way of solving this was to put everything in a globally accessible object or service. The store, as we mentioned, is just that. It is globally accessible in the sense that it can be injected into any component that might need it. A word of caution; even though it is tempting to put all of our state in our store, we really shouldn&#8217;t. State that we notice needs to be shared between components is worth putting there. </p>\n\n\n\n<p>Another benefit we get from having a centralized store is that it is very easy to save down the application&#8217;s state for later recovery. If state only lives in one place, a user, or the system, can easily persist that state to a backend so that next time, if they want to continue from where they left off, they can easily do so by querying the backend for that state. So, there does exist another reason for wanting a centralized store other than wanting to share the data between many components.</p>\n","protected":false},"excerpt":{"rendered":"<p>Some components must have state. When there is a need for another component to know about that very same state, the first component needs to find a way to communicate that to the other component. There are many ways to achieve this. One way is to ensure that all state that should be shared lives [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[40,83,162],"tags":[],"_links":{"self":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2495"}],"collection":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=2495"}],"version-history":[{"count":1,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2495/revisions"}],"predecessor-version":[{"id":2496,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2495/revisions/2496"}],"wp:attachment":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=2495"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=2495"},{"taxonomy":"post_tag","embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=2495"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":2497,"date":"2020-09-07T16:02:37","date_gmt":"2020-09-07T16:02:37","guid":{"rendered":"http://angular.foobrdigital.com/?p=2497"},"modified":"2021-04-26T06:42:23","modified_gmt":"2021-04-26T06:42:23","slug":"setting-up","status":"publish","type":"post","link":"https://angular.foobrdigital.com/setting-up/","title":{"rendered":"Setting Up"},"content":{"rendered":"\n<p>At this point, we need an Angular project. We use the Angular CLI for that, and scaffold ourselves a new project using the following command:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>ng new &lt;my new project&gt;</code></pre>\n\n\n\n<p>Once the scaffolding process is done, we navigate to our newly created director project with a simple&nbsp;<kbd>cd &lt;project dir&gt;</kbd>.We want to use the core functionality provided in the <kbd>@ngrx/store</kbd> library, therefore we install it by typing the following:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>npm install @ngrx/store --save </code></pre>\n\n\n\n<p>Let&#8217;s now open up the <kbd>app.module.ts</kbd> file&nbsp;in our scaffolded project. The time has come to import and register NgRx with <kbd>AppModule</kbd>:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// app.module.ts\n\nimport { BrowserModule } from \"@angular/platform-browser\";\nimport { NgModule } from \"@angular/core\";\nimport { StoreModule } from \"@ngrx/store\";\nimport { AppComponent } from \"./app.component\";\nimport { counterReducer } from \"./reducer\";\n\n@NgModule({\n  declarations: &#91;AppComponent],\n  imports: &#91;\n    BrowserModule,\n    StoreModule.forRoot({ counter: counterReducer }),\n  ],\n  bootstrap: &#91;AppComponent]\n})\nexport class AppModule {}</code></pre>\n\n\n\n<p>In the preceding code, we&#8217;ve highlighted the important part, which is importing&nbsp;<kbd>StoreModule</kbd>&nbsp;and registering it with&nbsp;<kbd>AppModule</kbd>&nbsp;by typing:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>StoreModule.forRoot({ counter: counterReducer })</code></pre>\n\n\n\n<p>Here, we are telling the store what state should exist, which is&nbsp;<kbd>counter</kbd>, and that <kbd>counterReducer</kbd> is the reducer meant to take care of that slice of state. As you can see, the code doesn&#8217;t quite work yet because we haven&#8217;t created&nbsp;<kbd>counterReducer</kbd>&nbsp;yet, let&#8217;s do that next:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// reducer.ts<br><br>export function counterReducer(state = 0, action) {<br>  switch(action.type) {<br>    case 'INCREMENT':<br>      return state + 1;<br>    case 'DECREMENT':<br>      return state -1;<br>    default:<br>      return state;<br>  }<br>}</code></pre>\n\n\n\n<p>It&#8217;s important to stress that reducers are so called pure functions that do not change the state, but produce a new state, given the old state plus the incoming action. Let&#8217;s show here how we would theoretically use our reducer if we wanted to use it outside of Redux. We do this just to demonstrate how reducers work:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>let state = counterReducer(0, { type: 'INCREMENT' });<br>// state is 1<br>state = counterReducer(state, { type: 'INCREMENT' });<br>// state is 2</code></pre>\n\n\n\n<p>As we can see from this, we start off with an initial value of <kbd>0</kbd>, and it computes a new value that results in <kbd>1</kbd>. Upon the second execution of the function, we provide it with the existing state, which has the value <kbd>0</kbd>. This results in our state now being <kbd>2</kbd>. This may look simple, but this is pretty much as complicated as a reducer can get. Normally, you wouldn&#8217;t execute the reducer function yourself but rather register it with the store and dispatch actions towards the store. This will lead to the reducer being invoked. So, how do we tell the store to dispatch? Simple, we use the function&nbsp;<kbd>dispatch()</kbd>&nbsp;on the store. For this code, let&#8217;s move to the&nbsp;<kbd>app.component.ts</kbd>&nbsp;file. We also need to create a file called&nbsp;<kbd>app-state.ts</kbd>, which is an interface, a typed representation of our store:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// app-state.ts\nexport interface AppState {\n  counter: number;\n}\n\n// app.component.ts\nimport { Component } from \"@angular/core\";\nimport { Store } from \"@ngrx/store\";\nimport { Observable } from \"rxjs/Observable\";\nimport { AppState } from \"./app-state\";\n\n@Component({\n  selector: \"app-root\",\n  template: `\n  {{ counter$ | async }}\n `\n})\nexport class AppComponent {\n  counter$;\n\n  constructor(private store: Store&lt;AppState&gt;) {\n    this.counter$ = store.select(\"counter\");\n  }\n}</code></pre>\n\n\n\n<p>What we can see from the preceding code is how we inject a store service into the constructor, like so:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>constructor(private store: Store&lt;AppState&gt;) {<br>  this.counter$ = store.select(\"counter\");<br>}</code></pre>\n\n\n\n<p>Thereafter, we call&nbsp;<kbd>store.select(\"count\")</kbd>, which means we are asking our store for the <kbd>count</kbd> property part of its state&nbsp;as that&#8217;s all this component cares about. A call&nbsp;<kbd>store.select()</kbd>&nbsp;returns an <kbd>Observable</kbd> that when resolved contains a value. We can easily show this value by adding it to the template markup, like so:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>{{ counter$ | async }}</code></pre>\n\n\n\n<p>That takes care of getting and displaying the state. What about dispatching an action? The store instance has a method on it called <kbd>dispatch()</kbd>, which takes an object containing the property type. So the following is perfectly good input:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// example input to a store<br><br>store.dispatch({ type: 'INCREMENT' });<br>store.dispatch({ type: 'INCREMENT', payload: 1 });<br>store.dispatch({})<br>// will throw an error, as it is missing the type property</code></pre>\n\n\n\n<p>Now, let&#8217;s build out our component a little, and create some methods and markup that will allow us to dispatch actions and see the end result of doing so:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// app.component.ts\n\nimport { Component } from \"@angular/core\";\nimport { Store } from \"@ngrx/store\";\nimport { AppState } from \"./app-state\";\n\n@Component({\n  selector: \"app-root\",\n  template: `\n  {{ counter$ | async }}\n  &lt;button (click)=\"increment()\" &gt;Increment&lt;/button&gt;\n  &lt;button (click)=\"decrement()\" &gt;Decrement&lt;/button&gt;\n `\n})\nexport class AppComponent {\n  counter$;\n\n  constructor(private store: Store&lt;AppState&gt;) {\n    this.counter$ = store.select(\"counter\");\n  }\n\n  increment() {\n    this.store.dispatch({ type: 'INCREMENT' });\n  }\n\n  decrement() {\n    this.store.dispatch({ type: 'DECREMENT' }); \n  }\n}</code></pre>\n\n\n\n<p>We added the&nbsp;<kbd>increment()</kbd>&nbsp;and&nbsp;<kbd>decrement()</kbd>&nbsp;methods to the class body, and also added two buttons to the markup that invoke said functions. Trying this out, we can see how our UI is updated for every press of the button. </p>\n\n\n\n<p>The reason for this working is, of course, that each dispatched action calls our&nbsp;<kbd>counterReducer</kbd>&nbsp;implicitly, and also because we hold a reference to our state in the form of the&nbsp;<kbd>counter$</kbd>&nbsp;variable. As this is an <kbd>Observable</kbd>, it means it will be updated when a change happens. </p>\n\n\n\n<p>The change is then pushed out to our&nbsp;<kbd>counter$</kbd>&nbsp;variable when an action is dispatched. It&#8217;s simple, but powerful.</p>\n","protected":false},"excerpt":{"rendered":"<p>At this point, we need an Angular project. We use the Angular CLI for that, and scaffold ourselves a new project using the following command: Once the scaffolding process is done, we navigate to our newly created director project with a simple&nbsp;cd &lt;project dir&gt;.We want to use the core functionality provided in the @ngrx/store library, [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[40,83,162],"tags":[],"_links":{"self":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2497"}],"collection":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=2497"}],"version-history":[{"count":2,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2497/revisions"}],"predecessor-version":[{"id":4984,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2497/revisions/4984"}],"wp:attachment":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=2497"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=2497"},{"taxonomy":"post_tag","embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=2497"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":2499,"date":"2020-09-07T16:08:26","date_gmt":"2020-09-07T16:08:26","guid":{"rendered":"http://angular.foobrdigital.com/?p=2499"},"modified":"2021-04-26T07:07:00","modified_gmt":"2021-04-26T07:07:00","slug":"complex-example","status":"publish","type":"post","link":"https://angular.foobrdigital.com/complex-example/","title":{"rendered":"Complex Example"},"content":{"rendered":"\n<p>We have so far learned how to set up NgRx by importing and registering its module. We have also been taught about the&nbsp;<kbd>select()</kbd>&nbsp;function that gives us a slice of state, and the&nbsp;<kbd>dispatch()</kbd>&nbsp;function that allows us to dispatch an action. These are the basics, we will use these very same basics and create a new reducer to reinforce what we already know, while introducing the concept payload.</p>\n\n\n\n<p>We need to do the following:</p>\n\n\n\n<ul><li>Tell the store we have a new state,&nbsp;<kbd>jedis</kbd></li><li>Create a&nbsp;<kbd>jediListReducer</kbd>&nbsp;and register it with the store</li><li>Create a component that supports showing our <kbd>jediList</kbd>, but is also able to dispatch actions that will change our slice of state&nbsp; <kbd>jedis</kbd></li></ul>\n\n\n\n<p>Let&#8217;s get down to business by defining our reducer,&nbsp;<kbd>jediListReducer</kbd>:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// jedi-list.reducer.ts<br>export function jediListReducer(state = &#91;], action) {<br>  switch(action.type) {<br>    case 'ADD_JEDI':<br>      return &#91; ...state, { ...action.payload }];<br>    case 'REMOVE_JEDI':<br>      return state.filter(jedi =&gt; jedi.id !== action.payload.id);<br>    case 'LOAD_JEDIS':<br>      return action.payload.map(jedi =&gt; ({...jedi}));<br>    default:<br>      return state;<br>  }<br>}</code></pre>\n\n\n\n<p>Let&#8217;s explain what goes on here for each case in our switch. First off, we have <kbd>ADD_JEDI</kbd>. We take our <kbd>action.payload</kbd> and add it to the list. Or technically, we take our existing list and construct a new list based on the old list, plus our new list item found in <kbd>action.payload</kbd>.&nbsp; Secondly we have <kbd>REMOVE_JEDI</kbd>&nbsp;that uses the&nbsp;<kbd>filter()</kbd>&nbsp;function to take away the list item that we don&#8217;t want to see. Lastly we have <kbd>LOAD_JEDIS</kbd>&nbsp;that takes in an existing list and replaces our state. Now, let&#8217;s demo this reducer by invoking it here:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>let state = jediListReducer(&#91;], { type: 'ADD_JEDI', payload : { id: 1, name: 'Yoda' });<br>// now contains &#91;{ id: 1, name: 'Yoda' }]<br><br>state = jediListReducer(state, { type: 'ADD_JEDI', payload: { id: 2, name: 'Darth Vader'} });<br>// now contains &#91;{ id: 1, name: 'Yoda' }, { id: 2, name: 'Darth Vader'}];<br><br>state = jediListReducer(state, { type: 'REMOVE JEDI', payload: { id: 1 } });<br>// now contains &#91;{ id: 2, name: 'Darth Vader'}];<br><br>state = jediListReducer(state, { type: 'LOAD_JEDIS', payload: &#91;] });<br>// now contains &#91;]</code></pre>\n\n\n\n<p>Now, let&#8217;s register this reducer with the store. We will therefore return to <kbd>app.module.ts</kbd>:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// app.module.ts\n\nimport { BrowserModule } from \"@angular/platform-browser\";\nimport { NgModule } from \"@angular/core\";\nimport { StoreModule } from \"@ngrx/store\";\nimport { AppComponent } from \"./app.component\";\nimport { counterReducer } from \"./reducer\";\nimport { jediListReducer } from \"./jedi-list-reducer\";\n\n@NgModule({\n  declarations: &#91;AppComponent],\n  imports: &#91;\n    BrowserModule,\n    StoreModule.forRoot({ \n      count: counterReducer, \n      jediList: jediListReducer }),\n  ],\n  bootstrap: &#91;AppComponent]\n})\nexport class AppModule {}</code></pre>\n\n\n\n<p>Because we just added a new state to our store, we should make the <kbd>app-state.ts</kbd> file aware of it, and we should also create a&nbsp;<kbd>Jedi</kbd> model so we can use that in our component later on:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// jedi.model.ts\n\nexport interface Jedi {\n  id: number;\n  name: string;\n}\n\n// app-state.ts\n\nimport { Jedi } from \"./jedi.model\";\n\nexport interface AppState {\n  counter: number;\n  jediList: Array&lt;Jedi&gt;;\n}</code></pre>\n\n\n\n<p>From the preceding code, we can see that&nbsp;<kbd>jediListReducer</kbd>, as well as the state&nbsp;<kbd>jediList</kbd>,&nbsp;is added to the object that serves as input to the&nbsp;<kbd>StoreModule.forRoot()</kbd>&nbsp;function. This means that NgRx is aware of this state and will let us retrieve it and dispatch actions to it. To do so, let&#8217;s build a component with just that. We need to create the&nbsp;<kbd>jedi-list.component.ts</kbd>&nbsp;file:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// jedi-list.component.ts\n\nimport { Component } from \"@angular/core\";\nimport { Store } from \"@ngrx/store\";\nimport { AppState } from \"../app-state\";\nimport { Jedi } from \"./jedi.model\";\n\n@Component({\n  selector: \"jedi-list\",\n  template: `\n  &lt;div *ngFor=\"let jedi of list$ | async\"&gt;\n    {{ jedi.name }}&lt;button (click)=\"remove(jedi.id)\" &gt;Remove&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;input &#91;(ngModel)]=\"newJedi\" placeholder=\"\" /&gt;\n  &lt;button (click)=\"add()\"&gt;Add&lt;/button&gt;\n  &lt;button (click)=\"clear()\" &gt;Clear&lt;/button&gt;\n `\n})\nexport class JediListComponent {\n  list$: Observable&lt;Array&lt;Jedi&gt;&gt;;\n  counter = 0;\n  newJedi = \"\";\n\n  constructor(private store: Store&lt;AppState&gt;) {\n    this.list$ = store.select(\"jediList\");\n  }\n\n  add() {\n    this.store.dispatch({ \n      type: 'ADD_JEDI', \n      payload: { id: this.counter++, name: this.newJedi } \n    });\n    this.newJedi = '';\n  }\n\n  remove(id) {\n    this.store.dispatch({ type: 'REMOVE_JEDI', payload: { id } }); \n  }\n\n  clear() {\n    this.store.dispatch({ type: 'LOAD_JEDIS', payload: &#91;] });\n    this.counter = 0;\n  }\n}</code></pre>\n\n\n\n<p>The last thing we need to do is to register this component with our module, and we should have a working application:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// app.module.ts\n\nimport { BrowserModule } from \"@angular/platform-browser\";\nimport { NgModule } from \"@angular/core\";\nimport { StoreModule } from \"@ngrx/store\";\nimport { AppComponent } from \"./app.component\";\nimport { counterReducer } from \"./reducer\";\nimport { jediListReducer } from \"./jedi-list.reducer\"; \nimport { JediListComponent } from './jedi-list.component';\n\n@NgModule({\n  declarations: &#91;AppComponent, JediListComponent ],\n  imports: &#91;\n    BrowserModule,\n    StoreModule.forRoot({ count: counterReducer, jediList: JediListReducer }),\n  ],\n  bootstrap: &#91;AppComponent]\n})\nexport class AppModule {}</code></pre>\n\n\n\n<p>So far, we have created some working code, but it could look a lot better, and be less error prone as well. There are steps we can take to improve the code, those are:</p>\n\n\n\n<ul><li>Get rid of so-called magic strings and rely on constants</li><li>Add a default state to your reducer</li><li>Create so-called action creators</li><li>Move everything into a dedicated module and split up it up into several components</li></ul>\n\n\n\n<p>Let&#8217;s have a look at our first bullet point. Given the type of actions we perform on our&nbsp;<kbd>jediList</kbd>,&nbsp;we can create a <kbd>constants.ts</kbd> file for them, like so:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// jedi.constants.ts<br><br>export const ADD_JEDI = 'ADD_JEDI';<br>export const REMOVE_JEDI = \"REMOVE_JEDI\";<br>export const LOAD_JEDIS =\"LOAD_JEDIS\";</code></pre>\n\n\n\n<p>Now, when we refer to these actions we can instead import this file and use these constants instead, decreasing the risk of us mistyping.</p>\n\n\n\n<p>The second thing we can do is to simplify the creation of actions by creating the so-called action creator. We are so far used to typing the following to create an action:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>const action = { type: 'ADD_JEDI', payload: { id: 1, name: 'Yoda' } };</code></pre>\n\n\n\n<p>A better habit here is to create a function that does this for us. For the case with the list reducer, there are three possible actions that can take place, so let&#8217;s put all these in a&nbsp;<kbd>actions.ts</kbd>&nbsp;file:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// jedi.actions.ts<br><br>import { <br>  ADD_JEDI, <br>  REMOVE_JEDI, <br>  LOAD_JEDIS <br>} from \"./jedi.constants\";<br><br>export const addJedi = (id, name) =&gt; ({ type: ADD_JEDI, payload: { id, name } });<br>export const removeJedi = (id) =&gt; ({ type: REMOVE_JEDI, payload:{ id } });<br>export const loadJedis = (jedis) =&gt; ({ type: LOAD_JEDIS, payload: jedis });</code></pre>\n\n\n\n<p>The point of creating the <kbd>actions.ts</kbd> file was so that we would have to write less code when we dispatch actions. Instead of writing the following:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>store.dispatch({ type: 'ADD_JEDI', payload: { id: 3, name: 'Luke' } });</code></pre>\n\n\n\n<p>We can now write this as:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// example of how we can dispatch to store using an actions method<br><br>import { addJedi } from './jedi.actions';<br>store.dispatch(addJedi(3, 'Luke'));</code></pre>\n","protected":false},"excerpt":{"rendered":"<p>We have so far learned how to set up NgRx by importing and registering its module. We have also been taught about the&nbsp;select()&nbsp;function that gives us a slice of state, and the&nbsp;dispatch()&nbsp;function that allows us to dispatch an action. These are the basics, we will use these very same basics and create a new reducer [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[40,83,162],"tags":[],"_links":{"self":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2499"}],"collection":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=2499"}],"version-history":[{"count":4,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2499/revisions"}],"predecessor-version":[{"id":4986,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2499/revisions/4986"}],"wp:attachment":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=2499"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=2499"},{"taxonomy":"post_tag","embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=2499"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":2502,"date":"2020-09-07T16:13:06","date_gmt":"2020-09-07T16:13:06","guid":{"rendered":"http://angular.foobrdigital.com/?p=2502"},"modified":"2021-04-26T07:07:29","modified_gmt":"2021-04-26T07:07:29","slug":"a-better-approach","status":"publish","type":"post","link":"https://angular.foobrdigital.com/a-better-approach/","title":{"rendered":"A Better Approach"},"content":{"rendered":"\n<p>Let&#8217;s explain where we are coming from, and why there might be a need to clean up your code. If you are starting out with a very simple app, you might add the reducer, the actions, and components in the root module of your project. This might create a mess as soon as you want to add another component. Let&#8217;s illustrate what our file structure might look like before we start cleaning up:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>app.component.ts<br>app.module.ts<br>jedi-list-reducer.ts<br>jedi-constants.ts<br>jedi-list-actions.ts<br>jedi-list-component.ts</code></pre>\n\n\n\n<p>From this,&nbsp; it&#8217;s pretty clear that this will only hold up if our app will only consist of that one component. As soon as we add more components, things will start to look messy.</p>\n\n\n\n<p>Let&#8217;s list what we need to do to create a better file structure, but also utilize the action creator, constants, and reducers in the best way possible:</p>\n\n\n\n<ul><li>Create a dedicated feature module and directory</li><li>Create action constants that the reducer and actions file can use</li><li>Create an action creator file with all the actions we mean to perform</li><li>Create a reducer that handles dispatches</li><li>Create a <kbd>JediList</kbd> component that is able to handle all actions we mean to use</li><li>Register our reducer and state with the store</li></ul>\n\n\n\n<h3>Create a dedicated directory and feature module</h3>\n\n\n\n<p>For that reason, we want to place everything in a dedicated directory, <kbd>jedi</kbd>. The easiest way to do that is to use the Angular CLI and run the following commands:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>ng g module jedi</code></pre>\n\n\n\n<p>The preceding code will generate the following files:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>jedi/\n  jedi.module.ts</code></pre>\n\n\n\n<p>Place yourself in your newly created <kbd>jedi</kbd> directory and type the following:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>ng g component jedi-list</code></pre>\n\n\n\n<p>This will add the following structure to your <kbd>jedi</kbd> directory:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>jedi/\n  jedi.module.ts\n  jedi-list/\n    jedi-list.component.html\n    jedi-list.component.ts\n    jedi-list.component.css\n    jedi-list.component.spec.ts</code></pre>\n\n\n\n<p>However, we have created the <kbd>jedi-list.component</kbd> and its belonging files in a previous section, so we will remove those scaffolded files for now and just move in the already created files under the <kbd>jedi-list</kbd> directory. So, your directory should look like:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>jedi/<br>  jedi.module.ts<br>  <strong>jedi-list/</strong></code></pre>\n","protected":false},"excerpt":{"rendered":"<p>Let&#8217;s explain where we are coming from, and why there might be a need to clean up your code. If you are starting out with a very simple app, you might add the reducer, the actions, and components in the root module of your project. This might create a mess as soon as you want [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[40,83,162],"tags":[],"_links":{"self":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2502"}],"collection":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=2502"}],"version-history":[{"count":2,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2502/revisions"}],"predecessor-version":[{"id":4987,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2502/revisions/4987"}],"wp:attachment":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=2502"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=2502"},{"taxonomy":"post_tag","embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=2502"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":2566,"date":"2020-09-07T17:25:15","date_gmt":"2020-09-07T17:25:15","guid":{"rendered":"http://angular.foobrdigital.com/?p=2566"},"modified":"2021-04-26T07:07:55","modified_gmt":"2021-04-26T07:07:55","slug":"adding-reducers","status":"publish","type":"post","link":"https://angular.foobrdigital.com/adding-reducers/","title":{"rendered":"Adding Reducers"},"content":{"rendered":"\n<p>Let&#8217;s create our reducer, like so:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// jedi/jedi-list/jedi-list.reducer.ts<br><br>import { <br>  ADD_JEDI, <br>  REMOVE_JEDI, <br>  LOAD_JEDIS <br>} from './jedi-list.constants.ts'<br><br>const initialState = &#91;];<br><br>export function jediListReducer(state = initialState, action) {<br>  switch(action.type) {<br>    case ADD_JEDI:<br>      return &#91; ...state, { ...action.payload }];<br>    case REMOVE_JEDI:<br>      return state.filter(jedi =&gt; jedi.id !== action.payload.id);<br>    case LOAD_JEDIS:<br>      return action.payload.map(jedi =&gt; ({ ...jedi}));<br>    default:<br>      return state;<br>  }<br>}</code></pre>\n\n\n\n<p>Our next order of business is our constants file, which has already been created&nbsp;and just need to move, like so:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// jedi/jedi-list/jedi-list-constants.ts<br><br>export const ADD_JEDI = 'ADD_JEDI';<br>export const REMOVE_JEDI = \"REMOVE_JEDI\";<br>export const LOAD_JEDIS =\"LOAD_JEDIS\";</code></pre>\n\n\n\n<p>A general tip is if you find the number of components and files growing, consider creating a dedicated directory for it.</p>\n\n\n\n<p>Next up is the action creator file that we have also already created, and that we just need to move to our <kbd>jedi</kbd> directory, like so:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// jedi/jedi-list/jedi-list-actions.ts<br><br>import { ADD_JEDI, REMOVE_JEDI, LOAD_JEDIS } from \"./jedi-list-constants\";<br><br>let counter = 0;<br><br>export const addJedi = (name) =&gt; ({ type: ADD_JEDI, payload: { id: counter++, name }});<br>export const removeJedi = (id) =&gt; ({ type: REMOVE_JEDI, payload: { id } });<br>export const loadJedis = (jedis) =&gt; ({ type: LOAD_JEDIS, payload: jedis });</code></pre>\n\n\n\n<p>Our directory should now look like this:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>jedi/\n  jedi.module.ts\n  jedi-list/    jedi-list.reducer.ts\n    jedi-list.actions.ts</code></pre>\n\n\n\n<p>The next point is about moving our&nbsp;<kbd>JediListComponent</kbd>&nbsp;to our <kbd>jedi</kbd> directory, like so:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// jedi/jedi-list/jedi-list.component.ts\n\nimport { Component } from \"@angular/core\";\nimport { Store } from \"@ngrx/store\";\nimport { Observable } from \"rxjs/Observable\";\nimport { AppState } from \"../app-state\";\nimport { \n  addJedi, \n  removeJedi, \n  loadJedis \n} from './jedi-list-actions';\n\n@Component({\n  selector: \"jedi-list\",\n  template: `\n  &lt;div *ngFor=\"let jedi of list$ | async\"&gt;\n    {{ jedi.name }}&lt;button (click)=\"remove(jedi.id)\" &gt;Remove&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;input &#91;(ngModel)]=\"newJedi\" placeholder=\"\" /&gt;\n  &lt;button (click)=\"add()\"&gt;Add&lt;/button&gt;\n  &lt;button (click)=\"clear()\" &gt;Clear&lt;/button&gt;\n `\n})\nexport class JediListComponent {\n  list$: Observable&lt;number&gt;;\n  counter = 0;\n  newJedi = \"\";\n\n  constructor(private store: Store&lt;AppState&gt;) {\n    this.list$ = store.select(\"jediList\");\n  }\n\n  add() {\n    this.store.dispatch(addJedi(this.newJedi));\n    this.newJedi = '';\n  }\n\n  remove(id) {\n    this.store.dispatch(removeJedi(id)); \n  }\n\n  clear() {\n    this.store.dispatch(loadJedis(&#91;]));\n    this.counter = 0;\n  }\n}</code></pre>\n\n\n\n<p>After moving our <kbd>jedi-list</kbd> component, our directory should now look like the following:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>jedi/<br>  jedi.module.ts<br>  jedi-list/    jedi-list.reducer.ts<br>    jedi-list.actions.ts    <strong>jedi-list.component.ts</strong></code></pre>\n","protected":false},"excerpt":{"rendered":"<p>Let&#8217;s create our reducer, like so: Our next order of business is our constants file, which has already been created&nbsp;and just need to move, like so: A general tip is if you find the number of components and files growing, consider creating a dedicated directory for it. Next up is the action creator file that [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[40,83,162],"tags":[],"_links":{"self":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2566"}],"collection":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=2566"}],"version-history":[{"count":2,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2566/revisions"}],"predecessor-version":[{"id":4988,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2566/revisions/4988"}],"wp:attachment":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=2566"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=2566"},{"taxonomy":"post_tag","embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=2566"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":2568,"date":"2020-09-07T17:26:47","date_gmt":"2020-09-07T17:26:47","guid":{"rendered":"http://angular.foobrdigital.com/?p=2568"},"modified":"2021-04-26T07:08:12","modified_gmt":"2021-04-26T07:08:12","slug":"registering-reducers","status":"publish","type":"post","link":"https://angular.foobrdigital.com/registering-reducers/","title":{"rendered":"Registering Reducers"},"content":{"rendered":"\n<p>Lastly, we just need to do a slight update to the <kbd>app.module.ts</kbd> file to have it point correctly to our&nbsp;<kbd>JediListReducer</kbd>,&nbsp;like so:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// app.module.ts\n\nimport { BrowserModule } from \"@angular/platform-browser\";\nimport { NgModule } from \"@angular/core\";\nimport { StoreModule } from \"@ngrx/store\";\nimport { AppComponent } from \"./app.component\";\nimport { counterReducer } from \"./reducer\";\nimport { JediModule } from './jedi/jedi.module';\nimport { jediListReducer } from \"./jedi/jedi-list/jedi-list.reducer\";  \n\n@NgModule({\n  declarations: &#91;AppComponent],\n  imports: &#91;\n    BrowserModule,\n    StoreModule.forRoot({ \n      counter: counterReducer, \n      jediList: JediListReducer \n    }),\n    JediModule\n  ],\n  bootstrap: &#91;AppComponent]\n})\nexport class AppModule {}</code></pre>\n\n\n\n<h3>Leveraging types and feature modules</h3>\n\n\n\n<p>The following files is pointing to the demo project <kbd>Chapter9/FeatureModules</kbd>.</p>\n\n\n\n<p>OK, one thing we can definitely improve is how we tell the <kbd>StoreModule</kbd> about what state and reducers exist in our app. Let&#8217;s do a quick recap and look at its current state:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// from app.module.ts\n\nStoreModule.forRoot({ count: counterReducer, jediList: JediListReducer })</code></pre>\n\n\n\n<p>So, we are essentially feeding the&nbsp;<kbd>forRoot()</kbd>&nbsp;method an object. What&#8217;s wrong with that? Well, imagine you have ten different feature modules and every feature module may have three to four states, then the object you pass to&nbsp;<kbd>forRoot()</kbd>&nbsp;will grow in size and the number of imports that you need to do in your <kbd>app.module.ts</kbd> will grow. It will look something like this:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>StoreModule.forRoot({ \n  featureModuleState1: featureModuleState1Reducer, \n  featureModuleState2 : featureModuleState2Reducer\n  .\n  .\n  .\n  .\n  .\n})</code></pre>\n","protected":false},"excerpt":{"rendered":"<p>Lastly, we just need to do a slight update to the app.module.ts file to have it point correctly to our&nbsp;JediListReducer,&nbsp;like so: Leveraging types and feature modules The following files is pointing to the demo project Chapter9/FeatureModules. OK, one thing we can definitely improve is how we tell the StoreModule about what state and reducers exist [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[40,83,162],"tags":[],"_links":{"self":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2568"}],"collection":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=2568"}],"version-history":[{"count":3,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2568/revisions"}],"predecessor-version":[{"id":4989,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2568/revisions/4989"}],"wp:attachment":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=2568"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=2568"},{"taxonomy":"post_tag","embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=2568"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":2571,"date":"2020-09-07T17:29:16","date_gmt":"2020-09-07T17:29:16","guid":{"rendered":"http://angular.foobrdigital.com/?p=2571"},"modified":"2021-04-26T07:08:43","modified_gmt":"2021-04-26T07:08:43","slug":"migrating-to-forfeature","status":"publish","type":"post","link":"https://angular.foobrdigital.com/migrating-to-forfeature/","title":{"rendered":"Migrating to forFeature()"},"content":{"rendered":"\n<p>To solve the mess we are creating in <kbd>app.module.ts,</kbd> we will now use a method called&nbsp;<kbd>forFeature()</kbd>&nbsp;on <kbd>StoreModule</kbd>&nbsp;that will allow us to set up the states we need per feature module. Let&#8217;s take the existing setup and refactor that:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// app.module.ts<br><br>StoreModule.forRoot({  }) // this would be empty</code></pre>\n\n\n\n<p>We move our two reducer entries to their respective feature modules, <kbd>counter.module.ts</kbd> and <kbd>jedi.module.ts</kbd>. That would now look like this:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// counter.module.ts<br>@NgModule({<br>  imports: &#91;StoreModule.forFeature(<br>    // add reducer object here<br>  )]<br>})<br><br>// jedi.module.ts<br>@NgModule({<br>  imports : &#91;StoreModule.forFeature(<br>  // add reducer here<br>  )]<br>})</code></pre>\n\n\n\n<p>We left out the implementation on purpose here because we need to take a step back. Remember when we called&nbsp;<kbd>StoreModule.forRoot()</kbd>, we could just pass it an object. It doesn&#8217;t look quite the same with&nbsp;<kbd>forFeature()</kbd>. There is a little bit of difference, so let&#8217;s try to explain what that difference is. We are used to setting up our store by passing it an object, which looks like this:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>{<br>  sliceOfState : reducerFunction,<br>  anotherSliceOfState: anotherReducerFunction<br>}</code></pre>\n\n\n\n<h3>Setting up forFeature() from string to selection function</h3>\n\n\n\n<p>We can set it up in pretty much the same way, but we need to pass it the name of a feature as well. Let&#8217;s take our <kbd>counter.module.ts</kbd> and add a little code to it:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// counter.module.ts<br><br>@NgModule({<br>  imports: &#91;<br>    StoreModule.forFeature('counter',{<br>      data: counterReducer    <br>    })<br>  ]<br>})</code></pre>\n\n\n\n<p>This will change how we select our state, though. Imagine we are inside of <kbd>counter.component.ts</kbd> with the current implementation looking like the following:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// counter.component.ts<br><br>@Component({<br>  selector: 'counter',<br>  template: `{{ counter$ | async }}`<br>})<br>export class CounterComponent {<br>  counter$;<br><br>  constructor(private store: Store&lt;AppState&gt;) {<br>    // this needs to change..<br>    this.counter$ = this.store.select('counter');<br>  }<br>}</code></pre>\n\n\n\n<p>Because we changed what the state looked like in <kbd>counter.module.ts</kbd>, we now need to reflect that in <kbd>counter.component.ts</kbd>, like so:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// counter.component.ts\n@Component({\n  selector: 'counter',\n  template: `{{ counter$ | async }}`\n})\nexport class CounterComponent {\n  counter$;\n\n  constructor(private store: Store&lt;AppState&gt;) {\n    this.counter$ = this.store.select((state) =&gt; {\n      return state.counter.data;\n    });\n  }\n}</code></pre>\n","protected":false},"excerpt":{"rendered":"<p>To solve the mess we are creating in app.module.ts, we will now use a method called&nbsp;forFeature()&nbsp;on StoreModule&nbsp;that will allow us to set up the states we need per feature module. Let&#8217;s take the existing setup and refactor that: We move our two reducer entries to their respective feature modules, counter.module.ts and jedi.module.ts. That would now [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[40,83,162],"tags":[],"_links":{"self":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2571"}],"collection":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=2571"}],"version-history":[{"count":3,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2571/revisions"}],"predecessor-version":[{"id":4990,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2571/revisions/4990"}],"wp:attachment":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=2571"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=2571"},{"taxonomy":"post_tag","embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=2571"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":2574,"date":"2020-09-07T17:49:17","date_gmt":"2020-09-07T17:49:17","guid":{"rendered":"http://angular.foobrdigital.com/?p=2574"},"modified":"2021-04-26T07:09:06","modified_gmt":"2021-04-26T07:09:06","slug":"ngrx-types","status":"publish","type":"post","link":"https://angular.foobrdigital.com/ngrx-types/","title":{"rendered":"NgRx Types"},"content":{"rendered":"\n<p>Up to this point, we have learned how we move the store state declaration from <kbd>app.module.ts</kbd> and register it in each&nbsp; feature module instead. This will provide us with a little more order. Let&#8217;s take a close look at the types used for registering state. <kbd>ActionReducerMap</kbd>&nbsp;is a type we have been using implicitly so far. We have been using it every time we call&nbsp;<kbd>StoreModule.forRoot()</kbd>&nbsp;or&nbsp;<kbd>StoreModule.forFeature()</kbd>. We have been using it in the sense that, the object we pass containing state and their reducers consists of this type. Let&#8217;s prove that is the case by turning to our <kbd>counter.module.ts</kbd>:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// counter.module.ts<br><br>@NgModule({<br>  imports: &#91;<br>    StoreModule.forFeature('counter',{<br>      data: counterReducer    <br>    })<br>  ]<br>})</code></pre>\n\n\n\n<p>Let&#8217;s change that a bit, to this:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// counter.reducer.ts\n\nexport interface CounterState = {\n  data: number\n};\n\nexport reducer: ActionReducerMap&lt;CounterState&gt; = {\n  data: counterReducer\n}\n\n// counter.module.ts\n\n@NgModule({\n  imports: &#91;\n    StoreModule.forFeature('counter', reducer)\n  ]\n})</code></pre>\n\n\n\n<p>Now, we can see that we are leveraging&nbsp;<kbd>ActionReducerMap</kbd>, which is a generic that forces us to provide it with a type. In this case, the type is&nbsp;<kbd>CounterState</kbd>. Running this code should just work. So, why use&nbsp;<kbd>ActionReducerMap</kbd>&nbsp;explicitly like this?</p>\n\n\n\n<h3>Giving forFeature() a type</h3>\n\n\n\n<p>Well, the&nbsp;<kbd>forFeature()</kbd>&nbsp;method is a generic as well,&nbsp;and we can specify this one explicitly like so:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// counter.module.ts\n\nconst CounterState = {\n  data: number\n};\n\nconst reducers: ActionReducerMap&lt;CounterState&gt; = {\n  data: counterReducer\n}\n\n@NgModule({\n  imports: &#91;\n    StoreModule.forFeature&lt;CounterState, Action&gt;('counter', reducers)\n  ]\n})</code></pre>\n\n\n\n<p>This protects us from adding a state mapping object that it does not expect to the&nbsp;<kbd>forFeature()</kbd> method. For instance, the following would render an error:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>// example of what NOT to do<strong>\n\n</strong>interface State {\n  test: string;\n}\n\nfunction testReducer(state =\"\", action: Action) {\n  switch(action.type) {\n    default:\n      return state;\n  }\n}\n\nconst reducers: ActionReducerMap&lt;State&gt; = {\n  test: testReducer\n};\n\n@NgModule({\n  imports: &#91;\n    BrowserModule,\n    StoreModule.forFeature&lt;CounterState, Action&gt;('counter', reducers)\n  ],\n  exports: &#91;CounterComponent, CounterListComponent],\n  declarations: &#91;CounterComponent, CounterListComponent],\n  providers: &#91;],\n})\nexport class CounterModule { }</code></pre>\n\n\n\n<p>The reason for this is that we are providing the wrong type to the&nbsp;<kbd>forFeature()</kbd>&nbsp;method. It expects a reducer parameter to be something of type <kbd>ActionReducerMap&lt;CounterState&gt;</kbd>, which&nbsp;it clearly is not, as we are sending in <kbd>ActionReducerMap&lt;State&gt;</kbd>.</p>\n","protected":false},"excerpt":{"rendered":"<p>Up to this point, we have learned how we move the store state declaration from app.module.ts and register it in each&nbsp; feature module instead. This will provide us with a little more order. Let&#8217;s take a close look at the types used for registering state. ActionReducerMap&nbsp;is a type we have been using implicitly so far. [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[40,83,162],"tags":[],"_links":{"self":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2574"}],"collection":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/comments?post=2574"}],"version-history":[{"count":3,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2574/revisions"}],"predecessor-version":[{"id":4992,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/posts/2574/revisions/4992"}],"wp:attachment":[{"href":"https://angular.foobrdigital.com/wp-json/wp/v2/media?parent=2574"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/categories?post=2574"},{"taxonomy":"post_tag","embeddable":true,"href":"https://angular.foobrdigital.com/wp-json/wp/v2/tags?post=2574"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}}]