[{"id":3857,"date":"2020-09-09T05:23:45","date_gmt":"2020-09-09T05:23:45","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=2038"},"modified":"2020-12-16T17:01:17","modified_gmt":"2020-12-16T17:01:17","slug":"scipy-tutorial","status":"publish","type":"post","link":"https://python3.foobrdigital.com/scipy-tutorial/","title":{"rendered":"SciPy Tutorial"},"content":{"rendered":"\n<p>SciPy, a scientific library for Python is an open source, BSD-licensed library for mathematics, science and engineering. The SciPy library depends on NumPy, which provides convenient and fast N-dimensional array manipulation. The main reason for building the SciPy library is that, it should work with NumPy arrays. It provides many user-friendly and efficient numerical practices such as routines for numerical integration and optimization. This is an introductory tutorial, which covers the fundamentals of SciPy and describes how to deal with its various modules.</p>\n\n\n\n<h1>Audience</h1>\n\n\n\n<p>This tutorial is prepared for the readers, who want to learn the basic features along with the various functions of SciPy. After completing this tutorial, the readers will find themselves at a moderate level of expertise, from where they can take themselves to higher levels of expertise.</p>\n\n\n\n<h1>Prerequisites</h1>\n\n\n\n<p>Before proceeding with the various concepts given in this tutorial, it is being expected that the readers have a basic understanding of Python. In addition to this, it will be very helpful, if the readers have some basic knowledge of other programming languages. SciPy library depends on the NumPy library, hence learning the basics of NumPy makes the understanding easy.</p>\n","protected":false},"excerpt":{"rendered":"<p>SciPy, a scientific library for Python is an open source, BSD-licensed library for mathematics, science and engineering. The SciPy library depends on NumPy, which provides convenient and fast N-dimensional array manipulation. The main reason for building the SciPy library is that, it should work with NumPy arrays. It provides many user-friendly and efficient numerical practices [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[100,154],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3857"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3857"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3857/revisions"}],"predecessor-version":[{"id":4220,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3857/revisions/4220"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3857"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3857"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3857"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3858,"date":"2020-09-09T05:24:21","date_gmt":"2020-09-09T05:24:21","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=2040"},"modified":"2020-12-16T17:01:16","modified_gmt":"2020-12-16T17:01:16","slug":"scipy-introduction","status":"publish","type":"post","link":"https://python3.foobrdigital.com/scipy-introduction/","title":{"rendered":"SciPy &#8211; Introduction"},"content":{"rendered":"\n<p>SciPy, pronounced as Sigh Pi, is a scientific python open source, distributed under the BSD licensed library to perform Mathematical, Scientific and Engineering Computations.</p>\n\n\n\n<p>The SciPy library depends on NumPy, which provides convenient and fast N-dimensional array manipulation. The SciPy library is built to work with NumPy arrays and provides many user-friendly and efficient numerical practices such as routines for numerical integration and optimization. Together, they run on all popular operating systems, are quick to install and are free of charge. NumPy and SciPy are easy to use, but powerful enough to depend on by some of the world&#8217;s leading scientists and engineers.</p>\n\n\n\n<h2>SciPy Sub-packages</h2>\n\n\n\n<p>SciPy is organized into sub-packages covering different scientific computing domains. These are summarized in the following table −</p>\n\n\n\n<figure class=\"wp-block-table\"><table><tbody><tr><td><a href=\"https://docs.scipy.org/doc/scipy/reference/cluster.html#module-scipy.cluster\" target=\"_blank\" rel=\"noreferrer noopener\">scipy.cluster</a></td><td>Vector quantization / Kmeans</td></tr><tr><td><a href=\"https://docs.scipy.org/doc/scipy/reference/constants.html#module-scipy.constants\" target=\"_blank\" rel=\"noreferrer noopener\">scipy.constants</a></td><td>Physical and mathematical constants</td></tr><tr><td><a href=\"https://docs.scipy.org/doc/scipy/reference/fftpack.html#module-scipy.fftpack\" target=\"_blank\" rel=\"noreferrer noopener\">scipy.fftpack</a></td><td>Fourier transform</td></tr><tr><td><a href=\"https://docs.scipy.org/doc/scipy/reference/integrate.html#module-scipy.integrate\" target=\"_blank\" rel=\"noreferrer noopener\">scipy.integrate</a></td><td>Integration routines</td></tr><tr><td><a href=\"https://docs.scipy.org/doc/scipy/reference/interpolate.html#module-scipy.interpolate\" target=\"_blank\" rel=\"noreferrer noopener\">scipy.interpolate</a></td><td>Interpolation</td></tr><tr><td><a href=\"https://docs.scipy.org/doc/scipy/reference/io.html#module-scipy.io\" target=\"_blank\" rel=\"noreferrer noopener\">scipy.io</a></td><td>Data input and output</td></tr><tr><td><a href=\"https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg\" target=\"_blank\" rel=\"noreferrer noopener\">scipy.linalg</a></td><td>Linear algebra routines</td></tr><tr><td><a href=\"https://docs.scipy.org/doc/scipy/reference/ndimage.html#module-scipy.ndimage\" target=\"_blank\" rel=\"noreferrer noopener\">scipy.ndimage</a></td><td>n-dimensional image package</td></tr><tr><td><a href=\"https://docs.scipy.org/doc/scipy/reference/odr.html#module-scipy.odr\" target=\"_blank\" rel=\"noreferrer noopener\">scipy.odr</a></td><td>Orthogonal distance regression</td></tr><tr><td><a href=\"https://docs.scipy.org/doc/scipy/reference/optimize.html#module-scipy.optimize\" target=\"_blank\" rel=\"noreferrer noopener\">scipy.optimize</a></td><td>Optimization</td></tr><tr><td><a href=\"https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal\" target=\"_blank\" rel=\"noreferrer noopener\">scipy.signal</a></td><td>Signal processing</td></tr><tr><td><a href=\"https://docs.scipy.org/doc/scipy/reference/sparse.html#module-scipy.sparse\" target=\"_blank\" rel=\"noreferrer noopener\">scipy.sparse</a></td><td>Sparse matrices</td></tr><tr><td><a href=\"https://docs.scipy.org/doc/scipy/reference/spatial.html#module-scipy.spatial\" target=\"_blank\" rel=\"noreferrer noopener\">scipy.spatial</a></td><td>Spatial data structures and algorithms</td></tr><tr><td><a href=\"https://docs.scipy.org/doc/scipy/reference/special.html#module-scipy.special\" target=\"_blank\" rel=\"noreferrer noopener\">scipy.special</a></td><td>Any special mathematical functions</td></tr><tr><td><a href=\"https://docs.scipy.org/doc/scipy/reference/stats.html#module-scipy.stats\" target=\"_blank\" rel=\"noreferrer noopener\">scipy.stats</a></td><td>Statistics</td></tr></tbody></table></figure>\n\n\n\n<h2>Data Structure</h2>\n\n\n\n<p>The basic data structure used by SciPy is a multidimensional array provided by the NumPy module. NumPy provides some functions for Linear Algebra, Fourier Transforms and Random Number Generation, but not with the generality of the equivalent functions in SciPy.</p>\n","protected":false},"excerpt":{"rendered":"<p>SciPy, pronounced as Sigh Pi, is a scientific python open source, distributed under the BSD licensed library to perform Mathematical, Scientific and Engineering Computations. The SciPy library depends on NumPy, which provides convenient and fast N-dimensional array manipulation. The SciPy library is built to work with NumPy arrays and provides many user-friendly and efficient numerical [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[100,154],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3858"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3858"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3858/revisions"}],"predecessor-version":[{"id":4219,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3858/revisions/4219"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3858"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3858"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3858"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3859,"date":"2020-09-09T05:25:06","date_gmt":"2020-09-09T05:25:06","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=2042"},"modified":"2020-12-16T17:01:16","modified_gmt":"2020-12-16T17:01:16","slug":"scipy-environment-setup","status":"publish","type":"post","link":"https://python3.foobrdigital.com/scipy-environment-setup/","title":{"rendered":"SciPy &#8211; Environment Setup"},"content":{"rendered":"\n<p>Standard Python distribution does not come bundled with any SciPy module. A lightweight alternative is to install SciPy using the popular Python package installer,</p>\n\n\n\n<pre class=\"wp-block-preformatted\">pip install pandas\n</pre>\n\n\n\n<p>If we install the&nbsp;<strong>Anaconda Python package</strong>, Pandas will be installed by default. Following are the packages and links to install them in different operating systems.</p>\n\n\n\n<h2>Windows</h2>\n\n\n\n<p><strong>Anaconda</strong>&nbsp;(from&nbsp;<a href=\"https://www.continuum.io/\" target=\"_blank\" rel=\"noreferrer noopener\">https://www.continuum.io</a>) is a free Python distribution for the SciPy stack. It is also available for Linux and Mac.</p>\n\n\n\n<p><strong>Canopy</strong>&nbsp;(<a href=\"https://www.enthought.com/products/canopy/\" rel=\"noreferrer noopener\" target=\"_blank\">https://www.enthought.com/products/canopy/</a>) is available free, as well as for commercial distribution with a full SciPy stack for Windows, Linux and Mac.</p>\n\n\n\n<p><strong>Python (x,y)</strong>&nbsp;− It is a free Python distribution with SciPy stack and Spyder IDE for Windows OS. (Downloadable from&nbsp;<a href=\"https://python-xy.github.io/\" target=\"_blank\" rel=\"noreferrer noopener\">https://python-xy.github.io/</a>)</p>\n\n\n\n<h3>Linux</h3>\n\n\n\n<p>Package managers of respective Linux distributions are used to install one or more packages in the SciPy stack.</p>\n\n\n\n<h3>Ubuntu</h3>\n\n\n\n<p>We can use the following path to install Python in Ubuntu.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>sudo apt-get install python-numpy python-scipy \npython-matplotlibipythonipython-notebook python-pandas python-sympy python-nose\n</code></pre>\n\n\n\n<h3>Fedora</h3>\n\n\n\n<p>We can use the following path to install Python in Fedora.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>sudo yum install numpyscipy python-matplotlibipython python-pandas \nsympy python-nose atlas-devel</code></pre>\n","protected":false},"excerpt":{"rendered":"<p>Standard Python distribution does not come bundled with any SciPy module. A lightweight alternative is to install SciPy using the popular Python package installer, pip install pandas If we install the&nbsp;Anaconda Python package, Pandas will be installed by default. Following are the packages and links to install them in different operating systems. Windows Anaconda&nbsp;(from&nbsp;https://www.continuum.io) is [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[100,154],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3859"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3859"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3859/revisions"}],"predecessor-version":[{"id":4218,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3859/revisions/4218"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3859"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3859"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3859"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3860,"date":"2020-09-09T05:26:40","date_gmt":"2020-09-09T05:26:40","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=2044"},"modified":"2020-12-16T17:01:16","modified_gmt":"2020-12-16T17:01:16","slug":"scipy-basic-functionality","status":"publish","type":"post","link":"https://python3.foobrdigital.com/scipy-basic-functionality/","title":{"rendered":"SciPy &#8211; Basic Functionality"},"content":{"rendered":"\n<p>By default, all the NumPy functions have been available through the SciPy namespace. There is no need to import the NumPy functions explicitly, when SciPy is imported. The main object of NumPy is the homogeneous multidimensional array. It is a table of elements (usually numbers), all of the same type, indexed by a tuple of positive integers. In NumPy, dimensions are called as axes. The number of&nbsp;<strong>axes</strong>&nbsp;is called as&nbsp;<strong>rank</strong>.</p>\n\n\n\n<p>Now, let us revise the basic functionality of Vectors and Matrices in NumPy. As SciPy is built on top of NumPy arrays, understanding of NumPy basics is necessary. As most parts of linear algebra deals with matrices only.</p>\n\n\n\n<h2>NumPy Vector</h2>\n\n\n\n<p>A Vector can be created in multiple ways. Some of them are described below.</p>\n\n\n\n<h3>Converting Python array-like objects to NumPy</h3>\n\n\n\n<p>Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import numpy as np\nlist = &#91;1,2,3,4]\narr = np.array(list)\nprint arr</code></pre>\n\n\n\n<p>The output of the above program will be as follows.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&#91;1 2 3 4]\n</code></pre>\n\n\n\n<h2>Intrinsic NumPy Array Creation</h2>\n\n\n\n<p>NumPy has built-in functions for creating arrays from scratch. Some of these functions are explained below.</p>\n\n\n\n<h3>Using zeros()</h3>\n\n\n\n<p>The zeros(shape) function will create an array filled with 0 values with the specified shape. The default dtype is float64. Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import numpy as np\nprint np.zeros((2, 3))</code></pre>\n\n\n\n<p>The output of the above program will be as follows.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>array(&#91;&#91; 0., 0., 0.],\n&#91; 0., 0., 0.]])\n</code></pre>\n\n\n\n<h3>Using ones()</h3>\n\n\n\n<p>The ones(shape) function will create an array filled with 1 values. It is identical to zeros in all the other respects. Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import numpy as np\nprint np.ones((2, 3))</code></pre>\n\n\n\n<p>The output of the above program will be as follows.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>array(&#91;&#91; 1., 1., 1.],\n&#91; 1., 1., 1.]])\n</code></pre>\n\n\n\n<h3>Using arange()</h3>\n\n\n\n<p>The arange() function will create arrays with regularly incrementing values. Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import numpy as np\nprint np.arange(7)</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>array(&#91;0, 1, 2, 3, 4, 5, 6])\n</code></pre>\n\n\n\n<h3>Defining the data type of the values</h3>\n\n\n\n<p>Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import numpy as np\narr = np.arange(2, 10, dtype = np.float)\nprint arr\nprint \"Array Data Type :\",arr.dtype</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&#91; 2. 3. 4. 5. 6. 7. 8. 9.]\nArray Data Type : float64\n</code></pre>\n\n\n\n<h3>Using linspace()</h3>\n\n\n\n<p>The linspace() function will create arrays with a specified number of elements, which will be spaced equally between the specified beginning and end values. Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import numpy as np\nprint np.linspace(1., 4., 6)</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>array(&#91; 1. , 1.6, 2.2, 2.8, 3.4, 4. ])\n</code></pre>\n\n\n\n<h2>Matrix</h2>\n\n\n\n<p>A matrix is a specialized 2-D array that retains its 2-D nature through operations. It has certain special operators, such as * (matrix multiplication) and ** (matrix power). Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import numpy as np\nprint np.matrix('1 2; 3 4')</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>matrix(&#91;&#91;1, 2],\n&#91;3, 4]])\n</code></pre>\n\n\n\n<h3>Conjugate Transpose of Matrix</h3>\n\n\n\n<p>This feature returns the (complex) conjugate transpose of&nbsp;<strong>self</strong>. Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import numpy as np\nmat = np.matrix('1 2; 3 4')\nprint mat.H</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>matrix(&#91;&#91;1, 3],\n        &#91;2, 4]])\n</code></pre>\n\n\n\n<h3>Transpose of Matrix</h3>\n\n\n\n<p>This feature returns the transpose of self. Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import numpy as np\nmat = np.matrix('1 2; 3 4')\nmat.T</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>matrix(&#91;&#91;1, 3],\n        &#91;2, 4]])\n</code></pre>\n\n\n\n<p>When we transpose a matrix, we make a new matrix whose rows are the columns of the original. A conjugate transposition, on the other hand, interchanges the row and the column index for each matrix element. The inverse of a matrix is a matrix that, if multiplied with the original matrix, results in an identity matrix.</p>\n","protected":false},"excerpt":{"rendered":"<p>By default, all the NumPy functions have been available through the SciPy namespace. There is no need to import the NumPy functions explicitly, when SciPy is imported. The main object of NumPy is the homogeneous multidimensional array. It is a table of elements (usually numbers), all of the same type, indexed by a tuple of [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[100,154],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3860"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3860"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3860/revisions"}],"predecessor-version":[{"id":4217,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3860/revisions/4217"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3860"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3860"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3860"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3861,"date":"2020-09-09T05:31:39","date_gmt":"2020-09-09T05:31:39","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=2048"},"modified":"2020-12-16T17:01:16","modified_gmt":"2020-12-16T17:01:16","slug":"scipy-cluster","status":"publish","type":"post","link":"https://python3.foobrdigital.com/scipy-cluster/","title":{"rendered":"SciPy &#8211; Cluster"},"content":{"rendered":"\n<p><strong>K-means clustering</strong>&nbsp;is a method for finding clusters and cluster centers in a set of unlabelled data. Intuitively, we might think of a cluster as – comprising of a group of data points, whose inter-point distances are small compared with the distances to points outside of the cluster. Given an initial set of K centers, the K-means algorithm iterates the following two steps −</p>\n\n\n\n<ul><li>For each center, the subset of training points (its cluster) that is closer to it is identified than any other center.</li><li>The mean of each feature for the data points in each cluster are computed, and this mean vector becomes the new center for that cluster.</li></ul>\n\n\n\n<p>These two steps are iterated until the centers no longer move or the assignments no longer change. Then, a new point&nbsp;<strong>x</strong>&nbsp;can be assigned to the cluster of the closest prototype. The SciPy library provides a good implementation of the K-Means algorithm through the cluster package. Let us understand how to use it.</p>\n\n\n\n<h2>K-Means Implementation in SciPy</h2>\n\n\n\n<p>We will understand how to implement K-Means in SciPy.</p>\n\n\n\n<h3>Import K-Means</h3>\n\n\n\n<p>We will see the implementation and usage of each imported function.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from SciPy.cluster.vq import kmeans,vq,whiten\n</code></pre>\n\n\n\n<h3>Data generation</h3>\n\n\n\n<p>We have to simulate some data to explore the clustering.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from numpy import vstack,array\nfrom numpy.random import rand\n\n# data generation with three features\ndata = vstack((rand(100,3) + array(&#91;.5,.5,.5]),rand(100,3)))</code></pre>\n\n\n\n<p>Now, we have to check for data. The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>array(&#91;&#91; 1.48598868e+00, 8.17445796e-01, 1.00834051e+00],\n       &#91; 8.45299768e-01, 1.35450732e+00, 8.66323621e-01],\n       &#91; 1.27725864e+00, 1.00622682e+00, 8.43735610e-01],\n       …………….\n</code></pre>\n\n\n\n<p>Normalize a group of observations on a per feature basis. Before running K-Means, it is beneficial to rescale each feature dimension of the observation set with whitening. Each feature is divided by its standard deviation across all observations to give it unit variance.</p>\n\n\n\n<h3>Whiten the data</h3>\n\n\n\n<p>We have to use the following code to whiten the data.</p>\n\n\n\n<pre class=\"wp-block-code\"><code># whitening of data\ndata = whiten(data)\n</code></pre>\n\n\n\n<h2>Compute K-Means with Three Clusters</h2>\n\n\n\n<p>Let us now compute K-Means with three clusters using the following code.</p>\n\n\n\n<pre class=\"wp-block-code\"><code># computing K-Means with K = 3 (2 clusters)\ncentroids,_ = kmeans(data,3)\n</code></pre>\n\n\n\n<p>The above code performs K-Means on a set of observation vectors forming K clusters. The K-Means algorithm adjusts the centroids until sufficient progress cannot be made, i.e. the change in distortion, since the last iteration is less than some threshold. Here, we can observe the centroid of the cluster by printing the centroids variable using the code given below.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>print(centroids)</code></pre>\n\n\n\n<p>The above code will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>print(centroids)&#91; &#91; 2.26034702  1.43924335  1.3697022 ]\n                  &#91; 2.63788572  2.81446462  2.85163854]\n                  &#91; 0.73507256  1.30801855  1.44477558] ]\n</code></pre>\n\n\n\n<p>Assign each value to a cluster by using the code given below.</p>\n\n\n\n<pre class=\"wp-block-code\"><code># assign each sample to a cluster\nclx,_ = vq(data,centroids)</code></pre>\n\n\n\n<p>The&nbsp;<strong>vq</strong>&nbsp;function compares each observation vector in the ‘M’ by ‘N’&nbsp;<strong>obs</strong>&nbsp;array with the centroids and assigns the observation to the closest cluster. It returns the cluster of each observation and the distortion. We can check the distortion as well. Let us check the cluster of each observation using the following code.</p>\n\n\n\n<pre class=\"wp-block-code\"><code># check clusters of observation\nprint clx</code></pre>\n\n\n\n<p>The above code will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>array(&#91;1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 2, 0, 2, 0, 1, 1, 1,\n0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0,\n0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,\n0, 1,  0, 0, 0, 0, 1, 0, 0, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 0, 2, 2, 2, 2, 2, 0, 0,\n2, 2, 2, 1, 0, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, \n2, 2, 0, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], dtype=int32)\n</code></pre>\n\n\n\n<p>The distinct values 0, 1, 2 of the above array indicate the clusters.</p>\n","protected":false},"excerpt":{"rendered":"<p>K-means clustering&nbsp;is a method for finding clusters and cluster centers in a set of unlabelled data. Intuitively, we might think of a cluster as – comprising of a group of data points, whose inter-point distances are small compared with the distances to points outside of the cluster. Given an initial set of K centers, the [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[100,154],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3861"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3861"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3861/revisions"}],"predecessor-version":[{"id":4216,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3861/revisions/4216"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3861"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3861"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3861"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3862,"date":"2020-09-09T05:32:34","date_gmt":"2020-09-09T05:32:34","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=2050"},"modified":"2020-12-16T17:01:16","modified_gmt":"2020-12-16T17:01:16","slug":"scipy-constants","status":"publish","type":"post","link":"https://python3.foobrdigital.com/scipy-constants/","title":{"rendered":"SciPy &#8211; Constants"},"content":{"rendered":"\n<p>SciPy constants package provides a wide range of constants, which are used in the general scientific area.</p>\n\n\n\n<h2>SciPy Constants Package</h2>\n\n\n\n<p>The&nbsp;<strong>scipy.constants package</strong>&nbsp;provides various constants. We have to import the required constant and use them as per the requirement. Let us see how these constant variables are imported and used.</p>\n\n\n\n<p>To start with, let us compare the ‘pi’ value by considering the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>#Import pi constant from both the packages\nfrom scipy.constants import pi\nfrom math import pi\n\nprint(\"sciPy - pi = %.16f\"%scipy.constants.pi)\nprint(\"math - pi = %.16f\"%math.pi)</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>sciPy - pi = 3.1415926535897931\nmath - pi = 3.1415926535897931\n</code></pre>\n\n\n\n<h2>List of Constants Available</h2>\n\n\n\n<p>The following tables describe in brief the various constants.</p>\n\n\n\n<h3>Mathematical Constants</h3>\n\n\n\n<figure class=\"wp-block-table\"><table><tbody><tr><th>Sr. No.</th><th>Constant</th><th>Description</th></tr><tr><td>1</td><td>pi</td><td>pi</td></tr><tr><td>2</td><td>golden</td><td>Golden Ratio</td></tr></tbody></table></figure>\n\n\n\n<h3>Physical Constants</h3>\n\n\n\n<p>The following table lists the most commonly used physical constants.</p>\n\n\n\n<figure class=\"wp-block-table\"><table><tbody><tr><th>Sr. No.</th><th>Constant &amp; Description</th></tr><tr><td>1</td><td><strong>c</strong>Speed of light in vacuum</td></tr><tr><td>2</td><td><strong>speed_of_light</strong>Speed of light in vacuum</td></tr><tr><td>3</td><td><strong>h</strong>Planck constant</td></tr><tr><td>4</td><td><strong>Planck</strong>Planck constant h</td></tr><tr><td>5</td><td><strong>G</strong>Newton’s gravitational constant</td></tr><tr><td>6</td><td><strong>e</strong>Elementary charge</td></tr><tr><td>7</td><td><strong>R</strong>Molar gas constant</td></tr><tr><td>8</td><td><strong>Avogadro</strong>Avogadro constant</td></tr><tr><td>9</td><td><strong>k</strong>Boltzmann constant</td></tr><tr><td>10</td><td><strong>electron_mass(OR) m_e</strong>Electronic mass</td></tr><tr><td>11</td><td><strong>proton_mass (OR) m_p</strong>Proton mass</td></tr><tr><td>12</td><td><strong>neutron_mass(OR)m_n</strong>Neutron mass</td></tr></tbody></table></figure>\n\n\n\n<h3>Units</h3>\n\n\n\n<p>The following table has the list of SI units.</p>\n\n\n\n<figure class=\"wp-block-table\"><table><tbody><tr><th>Sr. No.</th><th>Unit</th><th>Value</th></tr><tr><td>1</td><td>milli</td><td>0.001</td></tr><tr><td>2</td><td>micro</td><td>1e-06</td></tr><tr><td>3</td><td>kilo</td><td>1000</td></tr></tbody></table></figure>\n\n\n\n<p>These units range from yotta, zetta, exa, peta, tera ……kilo, hector, …nano, pico, … to zepto.</p>\n\n\n\n<h3>Other Important Constants</h3>\n\n\n\n<p>The following table lists other important constants used in SciPy.</p>\n\n\n\n<figure class=\"wp-block-table\"><table><tbody><tr><th>Sr. No.</th><th>Unit</th><th>Value</th></tr><tr><td>1</td><td>gram</td><td>0.001 kg</td></tr><tr><td>2</td><td>atomic mass</td><td>Atomic mass constant</td></tr><tr><td>3</td><td>degree</td><td>Degree in radians</td></tr><tr><td>4</td><td>minute</td><td>One minute in seconds</td></tr><tr><td>5</td><td>day</td><td>One day in seconds</td></tr><tr><td>6</td><td>inch</td><td>One inch in meters</td></tr><tr><td>7</td><td>micron</td><td>One micron in meters</td></tr><tr><td>8</td><td>light_year</td><td>One light-year in meters</td></tr><tr><td>9</td><td>atm</td><td>Standard atmosphere in pascals</td></tr><tr><td>10</td><td>acre</td><td>One acre in square meters</td></tr><tr><td>11</td><td>liter</td><td>One liter in cubic meters</td></tr><tr><td>12</td><td>gallon</td><td>One gallon in cubic meters</td></tr><tr><td>13</td><td>kmh</td><td>Kilometers per hour in meters per seconds</td></tr><tr><td>14</td><td>degree_Fahrenheit</td><td>One Fahrenheit in kelvins</td></tr><tr><td>15</td><td>eV</td><td>One electron volt in joules</td></tr><tr><td>16</td><td>hp</td><td>One horsepower in watts</td></tr><tr><td>17</td><td>dyn</td><td>One dyne in newtons</td></tr><tr><td>18</td><td>lambda2nu</td><td>Convert wavelength to optical frequency</td></tr></tbody></table></figure>\n\n\n\n<p>Remembering all of these are a bit tough. The easy way to get which key is for which function is with the&nbsp;<strong>scipy.constants.find()</strong>&nbsp;method. Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import scipy.constants\nres = scipy.constants.physical_constants&#91;\"alpha particle mass\"]\nprint res</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&#91;\n   'alpha particle mass',\n   'alpha particle mass energy equivalent',\n   'alpha particle mass energy equivalent in MeV',\n   'alpha particle mass in u',\n   'electron to alpha particle mass ratio'\n]\n</code></pre>\n\n\n\n<p>This method returns the list of keys, else nothing if the keyword does not match.</p>\n","protected":false},"excerpt":{"rendered":"<p>SciPy constants package provides a wide range of constants, which are used in the general scientific area. SciPy Constants Package The&nbsp;scipy.constants package&nbsp;provides various constants. We have to import the required constant and use them as per the requirement. Let us see how these constant variables are imported and used. To start with, let us compare [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[100,154],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3862"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3862"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3862/revisions"}],"predecessor-version":[{"id":4215,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3862/revisions/4215"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3862"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3862"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3862"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3863,"date":"2020-09-09T05:35:02","date_gmt":"2020-09-09T05:35:02","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=2052"},"modified":"2020-12-16T17:01:16","modified_gmt":"2020-12-16T17:01:16","slug":"scipy-fftpack","status":"publish","type":"post","link":"https://python3.foobrdigital.com/scipy-fftpack/","title":{"rendered":"SciPy &#8211; FFTpack"},"content":{"rendered":"\n<p><strong>Fourier Transformation</strong>&nbsp;is computed on a time domain signal to check its behavior in the frequency domain. Fourier transformation finds its application in disciplines such as signal and noise processing, image processing, audio signal processing, etc. SciPy offers the fftpack module, which lets the user compute fast Fourier transforms.</p>\n\n\n\n<p>Following is an example of a sine function, which will be used to calculate Fourier transform using the fftpack module.</p>\n\n\n\n<h2>Fast Fourier Transform</h2>\n\n\n\n<p>Let us understand what fast Fourier transform is in detail.</p>\n\n\n\n<h3>One Dimensional Discrete Fourier Transform</h3>\n\n\n\n<p>The FFT y[k] of length N of the length-N sequence x[n] is calculated by fft() and the inverse transform is calculated using ifft(). Let us consider the following example</p>\n\n\n\n<pre class=\"wp-block-code\"><code>#Importing the fft and inverse fft functions from fftpackage\nfrom scipy.fftpack import fft\n\n#create an array with random n numbers\nx = np.array(&#91;1.0, 2.0, 1.0, -1.0, 1.5])\n\n#Applying the fft function\ny = fft(x)\nprint y</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&#91; 4.50000000+0.j           2.08155948-1.65109876j   -1.83155948+1.60822041j\n -1.83155948-1.60822041j   2.08155948+1.65109876j ]\n</code></pre>\n\n\n\n<p>Let us look at another example</p>\n\n\n\n<pre class=\"wp-block-code\"><code>#FFT is already in the workspace, using the same workspace to for inverse transform\n\nyinv = ifft(y)\n\nprint yinv</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&#91; 1.0+0.j   2.0+0.j   1.0+0.j   -1.0+0.j   1.5+0.j ]\n</code></pre>\n\n\n\n<p>The&nbsp;<strong>scipy.fftpack</strong>&nbsp;module allows computing fast Fourier transforms. As an illustration, a (noisy) input signal may look as follows −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import numpy as np\ntime_step = 0.02\nperiod = 5.\ntime_vec = np.arange(0, 20, time_step)\nsig = np.sin(2 * np.pi / period * time_vec) + 0.5 *np.random.randn(time_vec.size)\nprint sig.size</code></pre>\n\n\n\n<p>We are creating a signal with a time step of 0.02 seconds. The last statement prints the size of the signal sig. The output would be as follows −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>1000\n</code></pre>\n\n\n\n<p>We do not know the signal frequency; we only know the sampling time step of the signal sig. The signal is supposed to come from a real function, so the Fourier transform will be symmetric. The&nbsp;<strong>scipy.fftpack.fftfreq()</strong>&nbsp;function will generate the sampling frequencies and&nbsp;<strong>scipy.fftpack.fft()</strong>&nbsp;will compute the fast Fourier transform.</p>\n\n\n\n<p>Let us understand this with the help of an example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy import fftpack\nsample_freq = fftpack.fftfreq(sig.size, d = time_step)\nsig_fft = fftpack.fft(sig)\nprint sig_fft</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>array(&#91; \n   25.45122234 +0.00000000e+00j,   6.29800973 +2.20269471e+00j,\n   11.52137858 -2.00515732e+01j,   1.08111300 +1.35488579e+01j,\n   …….])\n</code></pre>\n\n\n\n<h2>Discrete Cosine Transform</h2>\n\n\n\n<p>A&nbsp;<strong>Discrete Cosine Transform (DCT)</strong>&nbsp;expresses a finite sequence of data points in terms of a sum of cosine functions oscillating at different frequencies. SciPy provides a DCT with the function&nbsp;<strong>dct</strong>&nbsp;and a corresponding IDCT with the function&nbsp;<strong>idct</strong>. Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.fftpack import dct\nprint dct(np.array(&#91;4., 3., 5., 10., 5., 3.]))</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>array(&#91; 60.,  -3.48476592,  -13.85640646,  11.3137085,  6.,  -6.31319305])\n</code></pre>\n\n\n\n<p>The inverse discrete cosine transform reconstructs a sequence from its discrete cosine transform (DCT) coefficients. The idct function is the inverse of the dct function. Let us understand this with the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.fftpack import dct\nprint idct(np.array(&#91;4., 3., 5., 10., 5., 3.]))</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>array(&#91; 39.15085889, -20.14213562, -6.45392043, 7.13341236,\n8.14213562, -3.83035081])</code></pre>\n","protected":false},"excerpt":{"rendered":"<p>Fourier Transformation&nbsp;is computed on a time domain signal to check its behavior in the frequency domain. Fourier transformation finds its application in disciplines such as signal and noise processing, image processing, audio signal processing, etc. SciPy offers the fftpack module, which lets the user compute fast Fourier transforms. Following is an example of a sine [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[100,154],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3863"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3863"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3863/revisions"}],"predecessor-version":[{"id":4214,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3863/revisions/4214"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3863"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3863"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3863"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3864,"date":"2020-09-09T05:36:13","date_gmt":"2020-09-09T05:36:13","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=2054"},"modified":"2020-12-16T17:01:16","modified_gmt":"2020-12-16T17:01:16","slug":"scipy-integrate","status":"publish","type":"post","link":"https://python3.foobrdigital.com/scipy-integrate/","title":{"rendered":"SciPy &#8211; Integrate"},"content":{"rendered":"\n<p>When a function cannot be integrated analytically, or is very difficult to integrate analytically, one generally turns to numerical integration methods. SciPy has a number of routines for performing numerical integration. Most of them are found in the same&nbsp;<strong>scipy.integrate</strong>&nbsp;library. The following table lists some commonly used functions.</p>\n\n\n\n<figure class=\"wp-block-table\"><table><tbody><tr><th>Sr No.</th><th>Function &amp; Description</th></tr><tr><td>1</td><td><strong>quad</strong>Single integration</td></tr><tr><td>2</td><td><strong>dblquad</strong>Double integration</td></tr><tr><td>3</td><td><strong>tplquad</strong>Triple integration</td></tr><tr><td>4</td><td><strong>nquad</strong><em>n</em>-fold multiple integration</td></tr><tr><td>5</td><td><strong>fixed_quad</strong>Gaussian quadrature, order n</td></tr><tr><td>6</td><td><strong>quadrature</strong>Gaussian quadrature to tolerance</td></tr><tr><td>7</td><td><strong>romberg</strong>Romberg integration</td></tr><tr><td>8</td><td><strong>trapz</strong>Trapezoidal rule</td></tr><tr><td>9</td><td><strong>cumtrapz</strong>Trapezoidal rule to cumulatively compute integral</td></tr><tr><td>10</td><td><strong>simps</strong>Simpson’s rule</td></tr><tr><td>11</td><td><strong>romb</strong>Romberg integration</td></tr><tr><td>12</td><td><strong>polyint</strong>Analytical polynomial integration (NumPy)</td></tr><tr><td>13</td><td><strong>poly1d</strong>Helper function for polyint (NumPy)</td></tr></tbody></table></figure>\n\n\n\n<h2>Single Integrals</h2>\n\n\n\n<p>The Quad function is the workhorse of SciPy’s integration functions. Numerical integration is sometimes called&nbsp;<strong>quadrature</strong>, hence the name. It is normally the default choice for performing single integrals of a function&nbsp;<em>f(x)</em>&nbsp;over a given fixed range from a to b.</p>\n\n\n\n<p>$$\\int_{a}^{b} f(x)dx$$</p>\n\n\n\n<p>The general form of quad is&nbsp;<strong>scipy.integrate.quad(f, a, b)</strong>, Where ‘f’ is the name of the function to be integrated. Whereas, ‘a’ and ‘b’ are the lower and upper limits, respectively. Let us see an example of the Gaussian function, integrated over a range of 0 and 1.</p>\n\n\n\n<p>We first need to define the function → $f(x) = e^{-x^2}$ , this can be done using a lambda expression and then call the quad method on that function.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import scipy.integrate\nfrom numpy import exp\nf= lambda x:exp(-x**2)\ni = scipy.integrate.quad(f, 0, 1)\nprint i</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>(0.7468241328124271, 8.291413475940725e-15)\n</code></pre>\n\n\n\n<p>The quad function returns the two values, in which the first number is the value of integral and the second value is the estimate of the absolute error in the value of integral.</p>\n\n\n\n<p><strong>Note</strong>&nbsp;− Since quad requires the function as the first argument, we cannot directly pass exp as the argument. The Quad function accepts positive and negative infinity as limits. The Quad function can integrate standard predefined NumPy functions of a single variable, such as exp, sin and cos.</p>\n\n\n\n<h2>Multiple Integrals</h2>\n\n\n\n<p>The mechanics for double and triple integration have been wrapped up into the functions&nbsp;<strong>dblquad, tplquad</strong>&nbsp;and&nbsp;<strong>nquad</strong>. These functions integrate four or six arguments, respectively. The limits of all inner integrals need to be defined as functions.</p>\n\n\n\n<h2>Double Integrals</h2>\n\n\n\n<p>The general form of&nbsp;<strong>dblquad</strong>&nbsp;is scipy.integrate.dblquad(func, a, b, gfun, hfun). Where, func is the name of the function to be integrated, ‘a’ and ‘b’ are the lower and upper limits of the x variable, respectively, while gfun and hfun are the names of the functions that define the lower and upper limits of the y variable.</p>\n\n\n\n<p>As an example, let us perform the double integral method.</p>\n\n\n\n<p>$$\\int_{0}^{1/2} dy \\int_{0}^{\\sqrt{1-4y^2}} 16xy \\:dx$$</p>\n\n\n\n<p>We define the functions f, g, and h, using the lambda expressions. Note that even if g and h are constants, as they may be in many cases, they must be defined as functions, as we have done here for the lower limit.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import scipy.integrate\nfrom numpy import exp\nfrom math import sqrt\nf = lambda x, y : 16*x*y\ng = lambda x : 0\nh = lambda y : sqrt(1-4*y**2)\ni = scipy.integrate.dblquad(f, 0, 0.5, g, h)\nprint i</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>(0.5, 1.7092350012594845e-14)\n</code></pre>\n\n\n\n<p>In addition to the routines described above, scipy.integrate has a number of other integration routines, including nquad, which performs n-fold multiple integration, as well as other routines that implement various integration algorithms. However, quad and dblquad will meet most of our needs for numerical integration.</p>\n","protected":false},"excerpt":{"rendered":"<p>When a function cannot be integrated analytically, or is very difficult to integrate analytically, one generally turns to numerical integration methods. SciPy has a number of routines for performing numerical integration. Most of them are found in the same&nbsp;scipy.integrate&nbsp;library. The following table lists some commonly used functions. Sr No. Function &amp; Description 1 quadSingle integration [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[100,154],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3864"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3864"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3864/revisions"}],"predecessor-version":[{"id":4213,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3864/revisions/4213"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3864"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3864"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3864"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3865,"date":"2020-09-09T05:37:49","date_gmt":"2020-09-09T05:37:49","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=2056"},"modified":"2020-12-16T17:01:16","modified_gmt":"2020-12-16T17:01:16","slug":"scipy-interpolate","status":"publish","type":"post","link":"https://python3.foobrdigital.com/scipy-interpolate/","title":{"rendered":"SciPy &#8211; Interpolate"},"content":{"rendered":"\n<p>In this chapter, we will discuss how interpolation helps in SciPy.</p>\n\n\n\n<h2>What is Interpolation?</h2>\n\n\n\n<p>Interpolation is the process of finding a value between two points on a line or a curve. To help us remember what it means, we should think of the first part of the word, &#8216;inter,&#8217; as meaning &#8216;enter,&#8217; which reminds us to look &#8216;inside&#8217; the data we originally had. This tool, interpolation, is not only useful in statistics, but is also useful in science, business, or when there is a need to predict values that fall within two existing data points.</p>\n\n\n\n<p>Let us create some data and see how this interpolation can be done using the&nbsp;<strong>scipy.interpolate</strong>&nbsp;package.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import numpy as np\nfrom scipy import interpolate\nimport matplotlib.pyplot as plt\nx = np.linspace(0, 4, 12)\ny = np.cos(x**2/3+4)\nprint x,y</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>(\n   array(&#91;0.,  0.36363636,  0.72727273,  1.09090909,  1.45454545, 1.81818182, \n          2.18181818,  2.54545455,  2.90909091,  3.27272727,  3.63636364,  4.]),\n            \n   array(&#91;-0.65364362,  -0.61966189,  -0.51077021,  -0.31047698,  -0.00715476,\n           0.37976236,   0.76715099,   0.99239518,   0.85886263,   0.27994201,\n          -0.52586509,  -0.99582185])\n)\n</code></pre>\n\n\n\n<p>Now, we have two arrays. Assuming those two arrays as the two dimensions of the points in space, let us plot using the following program and see how they look like.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>plt.plot(x, y,’o’)\nplt.show()</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/scipy/images/interpolation.jpg\" alt=\"Interpolation\"/></figure>\n\n\n\n<h2>1-D Interpolation</h2>\n\n\n\n<p>The interp1d class in the scipy.interpolate is a convenient method to create a function based on fixed data points, which can be evaluated anywhere within the domain defined by the given data using linear interpolation.</p>\n\n\n\n<p>By using the above data, let us create a interpolate function and draw a new interpolated graph.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>f1 = interp1d(x, y,kind = 'linear')\n\nf2 = interp1d(x, y, kind = 'cubic')\n</code></pre>\n\n\n\n<p>Using the interp1d function, we created two functions f1 and f2. These functions, for a given input x returns y. The third variable kind represents the type of the interpolation technique. &#8216;Linear&#8217;, &#8216;Nearest&#8217;, &#8216;Zero&#8217;, &#8216;Slinear&#8217;, &#8216;Quadratic&#8217;, &#8216;Cubic&#8217; are a few techniques of interpolation.</p>\n\n\n\n<p>Now, let us create a new input of more length to see the clear difference of interpolation. We will use the same function of the old data on the new data.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>xnew = np.linspace(0, 4,30)\n\nplt.plot(x, y, 'o', xnew, f(xnew), '-', xnew, f2(xnew), '--')\n\nplt.legend(&#91;'data', 'linear', 'cubic','nearest'], loc = 'best')\n\nplt.show()</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/scipy/images/1d_interpolation.jpg\" alt=\"1-D Interpolation\"/></figure>\n\n\n\n<h2>Splines</h2>\n\n\n\n<p>To draw smooth curves through data points, drafters once used thin flexible strips of wood, hard rubber, metal or plastic called mechanical splines. To use a mechanical spline, pins were placed at a judicious selection of points along a curve in a design, and then the spline was bent, so that it touched each of these pins.</p>\n\n\n\n<p>Clearly, with this construction, the spline interpolates the curve at these pins. It can be used to reproduce the curve in other drawings. The points where the pins are located is called knots. We can change the shape of the curve defined by the spline by adjusting the location of the knots.</p>\n\n\n\n<h3>Univariate Spline</h3>\n\n\n\n<p>One-dimensional smoothing spline fits a given set of data points. The UnivariateSpline class in scipy.interpolate is a convenient method to create a function, based on fixed data points class – scipy.interpolate.UnivariateSpline(x, y, w = None, bbox = [None, None], k = 3, s = None, ext = 0, check_finite = False).</p>\n\n\n\n<p><strong>Parameters</strong>&nbsp;− Following are the parameters of a Univariate Spline.</p>\n\n\n\n<ul><li>This fits a spline y = spl(x) of degree k to the provided x, y data.</li><li>‘w’ − Specifies the weights for spline fitting. Must be positive. If none (default), weights are all equal.</li><li>‘s’ − Specifies the number of knots by specifying a smoothing condition.</li><li>‘k’ − Degree of the smoothing spline. Must be &lt;= 5. Default is k = 3, a cubic spline.</li><li>Ext − Controls the extrapolation mode for elements not in the interval defined by the knot sequence.<ul><li>if ext = 0 or ‘extrapolate’, returns the extrapolated value.</li><li>if ext = 1 or ‘zero’, returns 0</li><li>if ext = 2 or ‘raise’, raises a ValueError</li><li>if ext = 3 of ‘const’, returns the boundary value.</li></ul></li><li>check_finite – Whether to check that the input arrays contain only finite numbers.</li></ul>\n\n\n\n<p>Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import matplotlib.pyplot as plt\nfrom scipy.interpolate import UnivariateSpline\nx = np.linspace(-3, 3, 50)\ny = np.exp(-x**2) + 0.1 * np.random.randn(50)\nplt.plot(x, y, 'ro', ms = 5)\nplt.show()</code></pre>\n\n\n\n<p>Use the default value for the smoothing parameter.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/scipy/images/splines.jpg\" alt=\"Splines\"/></figure>\n\n\n\n<pre class=\"wp-block-code\"><code>spl = UnivariateSpline(x, y)\nxs = np.linspace(-3, 3, 1000)\nplt.plot(xs, spl(xs), 'g', lw = 3)\nplt.show()\n</code></pre>\n\n\n\n<p>Manually change the amount of smoothing.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/scipy/images/splines_smoothing.jpg\" alt=\"Splines Smoothing\"/></figure>\n\n\n\n<pre class=\"wp-block-code\"><code>spl.set_smoothing_factor(0.5)\nplt.plot(xs, spl(xs), 'b', lw = 3)\nplt.show()\n</code></pre>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/scipy/images/splines_smoothing2.jpg\" alt=\"Splines Smoothing\"/></figure>\n","protected":false},"excerpt":{"rendered":"<p>In this chapter, we will discuss how interpolation helps in SciPy. What is Interpolation? Interpolation is the process of finding a value between two points on a line or a curve. To help us remember what it means, we should think of the first part of the word, &#8216;inter,&#8217; as meaning &#8216;enter,&#8217; which reminds us [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[100,154],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3865"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3865"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3865/revisions"}],"predecessor-version":[{"id":4212,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3865/revisions/4212"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3865"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3865"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3865"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3866,"date":"2020-09-09T05:38:51","date_gmt":"2020-09-09T05:38:51","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=2058"},"modified":"2020-12-16T17:01:16","modified_gmt":"2020-12-16T17:01:16","slug":"scipy-input-output","status":"publish","type":"post","link":"https://python3.foobrdigital.com/scipy-input-output/","title":{"rendered":"SciPy &#8211; Input &#038; Output"},"content":{"rendered":"\n<p>The Scipy.io (Input and Output) package provides a wide range of functions to work around with different format of files. Some of these formats are −</p>\n\n\n\n<ul><li>Matlab</li><li>IDL</li><li>Matrix Market</li><li>Wave</li><li>Arff</li><li>Netcdf, etc.</li></ul>\n\n\n\n<p>Let us discuss in detail about the most commonly used file formats −</p>\n\n\n\n<h2>MATLAB</h2>\n\n\n\n<p>Following are the functions used to load and save a .mat file.</p>\n\n\n\n<figure class=\"wp-block-table\"><table><tbody><tr><th>Sr. No.</th><th>Function &amp; Description</th></tr><tr><td>1</td><td><strong>loadmat</strong>Loads a MATLAB file</td></tr><tr><td>2</td><td><strong>savemat</strong>Saves a MATLAB file</td></tr><tr><td>3</td><td><strong>whosmat</strong>Lists variables inside a MATLAB file</td></tr></tbody></table></figure>\n\n\n\n<p>Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import scipy.io as sio\nimport numpy as np\n\n#Save a mat file\nvect = np.arange(10)\nsio.savemat('array.mat', {'vect':vect})\n\n#Now Load the File\nmat_file_content = sio.loadmat(‘array.mat’)\nPrint mat_file_content</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>{\n   'vect': array(&#91;&#91;0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]), '__version__': '1.0', \n   '__header__': 'MATLAB 5.0 MAT-file Platform: posix, Created on: Sat Sep 30 \n   09:49:32 2017', '__globals__': &#91;]\n}\n</code></pre>\n\n\n\n<p>We can see the array along with the Meta information. If we want to inspect the contents of a MATLAB file without reading the data into memory, use the&nbsp;<strong>whosmat command</strong>&nbsp;as shown below.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import scipy.io as sio\nmat_file_content = sio.whosmat(‘array.mat’)\nprint mat_file_content</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&#91;('vect', (1, 10), 'int64')]</code></pre>\n","protected":false},"excerpt":{"rendered":"<p>The Scipy.io (Input and Output) package provides a wide range of functions to work around with different format of files. Some of these formats are − Matlab IDL Matrix Market Wave Arff Netcdf, etc. Let us discuss in detail about the most commonly used file formats − MATLAB Following are the functions used to load [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[100,154],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3866"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3866"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3866/revisions"}],"predecessor-version":[{"id":4211,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3866/revisions/4211"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3866"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3866"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3866"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3867,"date":"2020-09-09T05:40:23","date_gmt":"2020-09-09T05:40:23","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=2060"},"modified":"2020-12-16T17:01:16","modified_gmt":"2020-12-16T17:01:16","slug":"scipy-linalg","status":"publish","type":"post","link":"https://python3.foobrdigital.com/scipy-linalg/","title":{"rendered":"SciPy &#8211; Linalg"},"content":{"rendered":"\n<p>SciPy is built using the optimized&nbsp;<strong>ATLAS LAPACK</strong>&nbsp;and&nbsp;<strong>BLAS</strong>&nbsp;libraries. It has very fast linear algebra capabilities. All of these linear algebra routines expect an object that can be converted into a two-dimensional array. The output of these routines is also a two-dimensional array.</p>\n\n\n\n<h3>SciPy.linalg vs NumPy.linalg</h3>\n\n\n\n<p>A scipy.linalg contains all the functions that are in numpy.linalg. Additionally, scipy.linalg also has some other advanced functions that are not in numpy.linalg. Another advantage of using scipy.linalg over numpy.linalg is that it is always compiled with BLAS/LAPACK support, while for NumPy this is optional. Therefore, the SciPy version might be faster depending on how NumPy was installed.</p>\n\n\n\n<h2>Linear Equations</h2>\n\n\n\n<p>The&nbsp;<strong>scipy.linalg.solve</strong>&nbsp;feature solves the linear equation a * x + b * y = Z, for the unknown x, y values.</p>\n\n\n\n<p>As an example, assume that it is desired to solve the following simultaneous equations.</p>\n\n\n\n<p><strong>x + 3y + 5z = 10</strong></p>\n\n\n\n<p><strong>2x + 5y + z = 8</strong></p>\n\n\n\n<p><strong>2x + 3y + 8z = 3</strong></p>\n\n\n\n<p>To solve the above equation for the x, y, z values, we can find the solution vector using a matrix inverse as shown below.</p>\n\n\n\n<p>$$\\begin{bmatrix} x\\\\ y\\\\ z \\end{bmatrix} = \\begin{bmatrix} 1 &amp; 3 &amp; 5\\\\ 2 &amp; 5 &amp; 1\\\\ 2 &amp; 3 &amp; 8 \\end{bmatrix}^{-1} \\begin{bmatrix} 10\\\\ 8\\\\ 3 \\end{bmatrix} = \\frac{1}{25} \\begin{bmatrix} -232\\\\ 129\\\\ 19 \\end{bmatrix} = \\begin{bmatrix} -9.28\\\\ 5.16\\\\ 0.76 \\end{bmatrix}.$$</p>\n\n\n\n<p>However, it is better to use the&nbsp;<strong>linalg.solve</strong>&nbsp;command, which can be faster and more numerically stable.</p>\n\n\n\n<p>The solve function takes two inputs ‘a’ and ‘b’ in which ‘a’ represents the coefficients and ‘b’ represents the respective right hand side value and returns the solution array.</p>\n\n\n\n<p>Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>#importing the scipy and numpy packages\nfrom scipy import linalg\nimport numpy as np\n\n#Declaring the numpy arrays\na = np.array(&#91;&#91;3, 2, 0], &#91;1, -1, 0], &#91;0, 5, 1]])\nb = np.array(&#91;2, 4, -1])\n\n#Passing the values to the solve function\nx = linalg.solve(a, b)\n\n#printing the result array\nprint x</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>array(&#91; 2., -2., 9.])\n</code></pre>\n\n\n\n<h2>Finding a Determinant</h2>\n\n\n\n<p>The determinant of a square matrix A is often denoted as |A| and is a quantity often used in linear algebra. In SciPy, this is computed using the&nbsp;<strong>det()</strong>&nbsp;function. It takes a matrix as input and returns a scalar value.</p>\n\n\n\n<p>Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>#importing the scipy and numpy packages\nfrom scipy import linalg\nimport numpy as np\n\n#Declaring the numpy array\nA = np.array(&#91;&#91;1,2],&#91;3,4]])\n\n#Passing the values to the det function\nx = linalg.det(A)\n\n#printing the result\nprint x</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>-2.0\n</code></pre>\n\n\n\n<h2>Eigenvalues and Eigenvectors</h2>\n\n\n\n<p>The eigenvalue-eigenvector problem is one of the most commonly employed linear algebra operations. We can find the Eigen values (λ) and the corresponding Eigen vectors (v) of a square matrix (A) by considering the following relation −</p>\n\n\n\n<p><strong>Av = λv</strong></p>\n\n\n\n<p><strong>scipy.linalg.eig</strong>&nbsp;computes the eigenvalues from an ordinary or generalized eigenvalue problem. This function returns the Eigen values and the Eigen vectors.</p>\n\n\n\n<p>Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>#importing the scipy and numpy packages\nfrom scipy import linalg\nimport numpy as np\n\n#Declaring the numpy array\nA = np.array(&#91;&#91;1,2],&#91;3,4]])\n\n#Passing the values to the eig function\nl, v = linalg.eig(A)\n\n#printing the result for eigen values\nprint l\n\n#printing the result for eigen vectors\nprint v</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>array(&#91;-0.37228132+0.j, 5.37228132+0.j]) #--Eigen Values\narray(&#91;&#91;-0.82456484, -0.41597356], #--Eigen Vectors\n       &#91; 0.56576746, -0.90937671]])\n</code></pre>\n\n\n\n<h2>Singular Value Decomposition</h2>\n\n\n\n<p>A Singular Value Decomposition (SVD) can be thought of as an extension of the eigenvalue problem to matrices that are not square.</p>\n\n\n\n<p>The&nbsp;<strong>scipy.linalg.svd</strong>&nbsp;factorizes the matrix ‘a’ into two unitary matrices ‘U’ and ‘Vh’ and a 1-D array ‘s’ of singular values (real, non-negative) such that a == U*S*Vh, where ‘S’ is a suitably shaped matrix of zeros with the main diagonal ‘s’.</p>\n\n\n\n<p>Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>#importing the scipy and numpy packages\nfrom scipy import linalg\nimport numpy as np\n\n#Declaring the numpy array\na = np.random.randn(3, 2) + 1.j*np.random.randn(3, 2)\n\n#Passing the values to the eig function\nU, s, Vh = linalg.svd(a)\n\n# printing the result\nprint U, Vh, s</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>(\n   array(&#91;\n      &#91; 0.54828424-0.23329795j, -0.38465728+0.01566714j,\n      -0.18764355+0.67936712j],\n      &#91;-0.27123194-0.5327436j , -0.57080163-0.00266155j,\n      -0.39868941-0.39729416j],\n      &#91; 0.34443818+0.4110186j , -0.47972716+0.54390586j,\n      0.25028608-0.35186815j]\n   ]),\n\n   array(&#91; 3.25745379, 1.16150607]),\n\n   array(&#91;\n      &#91;-0.35312444+0.j , 0.32400401+0.87768134j],\n      &#91;-0.93557636+0.j , -0.12229224-0.33127251j]\n   ])\n)</code></pre>\n","protected":false},"excerpt":{"rendered":"<p>SciPy is built using the optimized&nbsp;ATLAS LAPACK&nbsp;and&nbsp;BLAS&nbsp;libraries. It has very fast linear algebra capabilities. All of these linear algebra routines expect an object that can be converted into a two-dimensional array. The output of these routines is also a two-dimensional array. SciPy.linalg vs NumPy.linalg A scipy.linalg contains all the functions that are in numpy.linalg. Additionally, [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[100,154],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3867"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3867"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3867/revisions"}],"predecessor-version":[{"id":4210,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3867/revisions/4210"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3867"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3867"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3867"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3868,"date":"2020-09-09T05:41:58","date_gmt":"2020-09-09T05:41:58","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=2062"},"modified":"2020-12-16T17:01:16","modified_gmt":"2020-12-16T17:01:16","slug":"scipy-ndimage","status":"publish","type":"post","link":"https://python3.foobrdigital.com/scipy-ndimage/","title":{"rendered":"SciPy &#8211; Ndimage"},"content":{"rendered":"\n<p>The SciPy ndimage submodule is dedicated to image processing. Here, ndimage means an n-dimensional image.</p>\n\n\n\n<p>Some of the most common tasks in image processing are as follows &amp;miuns;</p>\n\n\n\n<ul><li>Input/Output, displaying images</li><li>Basic manipulations − Cropping, flipping, rotating, etc.</li><li>Image filtering − De-noising, sharpening, etc.</li><li>Image segmentation − Labeling pixels corresponding to different objects</li><li>Classification</li><li>Feature extraction</li><li>Registration</li></ul>\n\n\n\n<p>Let us discuss how some of these can be achieved using SciPy.</p>\n\n\n\n<h2>Opening and Writing to Image Files</h2>\n\n\n\n<p>The&nbsp;<strong>misc package</strong>&nbsp;in SciPy comes with some images. We use those images to learn the image manipulations. Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy import misc\nf = misc.face()\nmisc.imsave('face.png', f) # uses the Image module (PIL)\n\nimport matplotlib.pyplot as plt\nplt.imshow(f)\nplt.show()</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/scipy/images/opening_and_writing_to_image_files.jpg\" alt=\"Opening and Writing to Image Files\"/></figure>\n\n\n\n<p>Any images in its raw format is the combination of colors represented by the numbers in the matrix format. A machine understands and manipulates the images based on those numbers only. RGB is a popular way of representation.</p>\n\n\n\n<p>Let us see the statistical information of the above image.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy import misc\nface = misc.face(gray = False)\nprint face.mean(), face.max(), face.min()</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>110.16274388631184, 255, 0\n</code></pre>\n\n\n\n<p>Now, we know that the image is made out of numbers, so any change in the value of the number alters the original image. Let us perform some geometric transformations on the image. The basic geometric operation is cropping</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy import misc\nface = misc.face(gray = True)\nlx, ly = face.shape\n# Cropping\ncrop_face = face&#91;lx / 4: - lx / 4, ly / 4: - ly / 4]\nimport matplotlib.pyplot as plt\nplt.imshow(crop_face)\nplt.show()</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/scipy/images/cropping_operation_image_files.jpg\" alt=\"Cropping Operation Image Files\"/></figure>\n\n\n\n<p>We can also perform some basic operations such as turning the image upside down as described below.</p>\n\n\n\n<pre class=\"wp-block-code\"><code># up &lt;-> down flip\nfrom scipy import misc\nface = misc.face()\nflip_ud_face = np.flipud(face)\n\nimport matplotlib.pyplot as plt\nplt.imshow(flip_ud_face)\nplt.show()\n</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/scipy/images/image_turning_operation.jpg\" alt=\"Image Turning Operation\"/></figure>\n\n\n\n<p>Besides this, we have the&nbsp;<strong>rotate() function</strong>, which rotates the image with a specified angle.</p>\n\n\n\n<pre class=\"wp-block-code\"><code># rotation\nfrom scipy import misc,ndimage\nface = misc.face()\nrotate_face = ndimage.rotate(face, 45)\n\nimport matplotlib.pyplot as plt\nplt.imshow(rotate_face)\nplt.show()</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/scipy/images/image_rotation_operation.jpg\" alt=\"Image Rotation Operation\"/></figure>\n\n\n\n<h2>Filters</h2>\n\n\n\n<p>Let us discuss how filters help in image processing.</p>\n\n\n\n<h3>What is filtering in image processing?</h3>\n\n\n\n<p>Filtering is a technique for modifying or enhancing an image. For example, you can filter an image to emphasize certain features or remove other features. Image processing operations implemented with filtering include Smoothing, Sharpening, and Edge Enhancement.</p>\n\n\n\n<p>Filtering is a neighborhood operation, in which the value of any given pixel in the output image is determined by applying some algorithm to the values of the pixels in the neighborhood of the corresponding input pixel. Let us now perform a few operations using SciPy ndimage.</p>\n\n\n\n<h3>Blurring</h3>\n\n\n\n<p>Blurring is widely used to reduce the noise in the image. We can perform a filter operation and see the change in the image. Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy import misc\nface = misc.face()\nblurred_face = ndimage.gaussian_filter(face, sigma=3)\nimport matplotlib.pyplot as plt\nplt.imshow(blurred_face)\nplt.show()</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/scipy/images/image_blurring_operation.jpg\" alt=\"Image Blurring Operation\"/></figure>\n\n\n\n<p>The sigma value indicates the level of blur on a scale of five. We can see the change on the image quality by tuning the sigma value. For more details of blurring, click on → DIP (Digital Image Processing) Tutorial.</p>\n\n\n\n<h2>Edge Detection</h2>\n\n\n\n<p>Let us discuss how edge detection helps in image processing.</p>\n\n\n\n<h3>What is Edge Detection?</h3>\n\n\n\n<p>Edge detection is an image processing technique for finding the boundaries of objects within images. It works by detecting discontinuities in brightness. Edge detection is used for image segmentation and data extraction in areas such as Image Processing, Computer Vision and Machine Vision.</p>\n\n\n\n<p>The most commonly used edge detection algorithms include</p>\n\n\n\n<ul><li>Sobel</li><li>Canny</li><li>Prewitt</li><li>Roberts</li><li>Fuzzy Logic methods</li></ul>\n\n\n\n<p>Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import scipy.ndimage as nd\nimport numpy as np\n\nim = np.zeros((256, 256))\nim&#91;64:-64, 64:-64] = 1\nim&#91;90:-90,90:-90] = 2\nim = ndimage.gaussian_filter(im, 8)\n\nimport matplotlib.pyplot as plt\nplt.imshow(im)\nplt.show()</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/scipy/images/edge_detection.jpg\" alt=\"Edge Detection\"/></figure>\n\n\n\n<p>The image looks like a square block of colors. Now, we will detect the edges of those colored blocks. Here, ndimage provides a function called&nbsp;<strong>Sobel</strong>&nbsp;to carry out this operation. Whereas, NumPy provides the&nbsp;<strong>Hypot</strong>&nbsp;function to combine the two resultant matrices to one.</p>\n\n\n\n<p>Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import scipy.ndimage as nd\nimport matplotlib.pyplot as plt\n\nim = np.zeros((256, 256))\nim&#91;64:-64, 64:-64] = 1\nim&#91;90:-90,90:-90] = 2\nim = ndimage.gaussian_filter(im, 8)\n\nsx = ndimage.sobel(im, axis = 0, mode = 'constant')\nsy = ndimage.sobel(im, axis = 1, mode = 'constant')\nsob = np.hypot(sx, sy)\n\nplt.imshow(sob)\nplt.show()</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/scipy/images/edge_detection_2.jpg\" alt=\"Edge Detection-2\"/></figure>\n","protected":false},"excerpt":{"rendered":"<p>The SciPy ndimage submodule is dedicated to image processing. Here, ndimage means an n-dimensional image. Some of the most common tasks in image processing are as follows &amp;miuns; Input/Output, displaying images Basic manipulations − Cropping, flipping, rotating, etc. Image filtering − De-noising, sharpening, etc. Image segmentation − Labeling pixels corresponding to different objects Classification Feature [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[100,154],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3868"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3868"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3868/revisions"}],"predecessor-version":[{"id":4209,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3868/revisions/4209"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3868"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3868"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3868"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3869,"date":"2020-09-09T05:43:22","date_gmt":"2020-09-09T05:43:22","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=2064"},"modified":"2020-12-16T17:01:16","modified_gmt":"2020-12-16T17:01:16","slug":"scipy-optimize","status":"publish","type":"post","link":"https://python3.foobrdigital.com/scipy-optimize/","title":{"rendered":"SciPy &#8211; Optimize"},"content":{"rendered":"\n<p>The&nbsp;<strong>scipy.optimize package</strong>&nbsp;provides several commonly used optimization algorithms. This module contains the following aspects −</p>\n\n\n\n<ul><li>Unconstrained and constrained minimization of multivariate scalar functions (minimize()) using a variety of algorithms (e.g. BFGS, Nelder-Mead simplex, Newton Conjugate Gradient, COBYLA or SLSQP)</li><li>Global (brute-force) optimization routines (e.g., anneal(), basinhopping())</li><li>Least-squares minimization (leastsq()) and curve fitting (curve_fit()) algorithms</li><li>Scalar univariate functions minimizers (minimize_scalar()) and root finders (newton())</li><li>Multivariate equation system solvers (root()) using a variety of algorithms (e.g. hybrid Powell, Levenberg-Marquardt or large-scale methods such as Newton-Krylov)</li></ul>\n\n\n\n<h3>Unconstrained &amp; Constrained minimization of multivariate scalar functions</h3>\n\n\n\n<p>The&nbsp;<strong>minimize() function</strong>&nbsp;provides a common interface to unconstrained and constrained minimization algorithms for multivariate scalar functions in&nbsp;<strong>scipy.optimize</strong>. To demonstrate the minimization function, consider the problem of minimizing the Rosenbrock function of the NN variables −</p>\n\n\n\n<p>$$f(x) = \\sum_{i = 1}^{N-1} \\:100(x_i &#8211; x_{i-1}^{2})$$</p>\n\n\n\n<p>The minimum value of this function is 0, which is achieved when xi = 1.</p>\n\n\n\n<h2>Nelder–Mead Simplex Algorithm</h2>\n\n\n\n<p>In the following example, the minimize() routine is used with the&nbsp;<strong>Nelder-Mead simplex algorithm (method = &#8216;Nelder-Mead&#8217;)</strong>&nbsp;(selected through the method parameter). Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import numpy as np\nfrom scipy.optimize import minimize\n\ndef rosen(x):\n\nx0 = np.array(&#91;1.3, 0.7, 0.8, 1.9, 1.2])\nres = minimize(rosen, x0, method='nelder-mead')\n\nprint(res.x)</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&#91;7.93700741e+54  -5.41692163e+53  6.28769150e+53  1.38050484e+55  -4.14751333e+54]\n</code></pre>\n\n\n\n<p>The simplex algorithm is probably the simplest way to minimize a fairly well-behaved function. It requires only function evaluations and is a good choice for simple minimization problems. However, because it does not use any gradient evaluations, it may take longer to find the minimum.</p>\n\n\n\n<p>Another optimization algorithm that needs only function calls to find the minimum is the&nbsp;<strong>Powell‘s method</strong>, which is available by setting method = &#8216;powell&#8217; in the minimize() function.</p>\n\n\n\n<h2>Least Squares</h2>\n\n\n\n<p>Solve a nonlinear least-squares problem with bounds on the variables. Given the residuals f(x) (an m-dimensional real function of n real variables) and the loss function rho(s) (a scalar function), least_squares find a local minimum of the cost function F(x). Let us consider the following example.</p>\n\n\n\n<p>In this example, we find a minimum of the Rosenbrock function without bounds on the independent variables.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>#Rosenbrock Function\ndef fun_rosenbrock(x):\n   return np.array(&#91;10 * (x&#91;1] - x&#91;0]**2), (1 - x&#91;0])])\n   \nfrom scipy.optimize import least_squares\ninput = np.array(&#91;2, 2])\nres = least_squares(fun_rosenbrock, input)\n\nprint res</code></pre>\n\n\n\n<p>Notice that, we only provide the vector of the residuals. The algorithm constructs the cost function as a sum of squares of the residuals, which gives the Rosenbrock function. The exact minimum is at x = [1.0,1.0].</p>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>active_mask: array(&#91; 0., 0.])\n      cost: 9.8669242910846867e-30\n      fun: array(&#91; 4.44089210e-15, 1.11022302e-16])\n      grad: array(&#91; -8.89288649e-14, 4.44089210e-14])\n      jac: array(&#91;&#91;-20.00000015,10.],&#91; -1.,0.]])\n   message: '`gtol` termination condition is satisfied.'\n      nfev: 3\n      njev: 3\n   optimality: 8.8928864934219529e-14\n      status: 1\n      success: True\n         x: array(&#91; 1., 1.])\n</code></pre>\n\n\n\n<h2>Root finding</h2>\n\n\n\n<p>Let us understand how root finding helps in SciPy.</p>\n\n\n\n<h3>Scalar functions</h3>\n\n\n\n<p>If one has a single-variable equation, there are four different root-finding algorithms, which can be tried. Each of these algorithms require the endpoints of an interval in which a root is expected (because the function changes signs). In general,&nbsp;<strong>brentq</strong>&nbsp;is the best choice, but the other methods may be useful in certain circumstances or for academic purposes.</p>\n\n\n\n<h3>Fixed-point solving</h3>\n\n\n\n<p>A problem closely related to finding the zeros of a function is the problem of finding a fixed point of a function. A fixed point of a function is the point at which evaluation of the function returns the point: g(x) = x. Clearly the fixed point of&nbsp;<strong>gg</strong>&nbsp;is the root of f(x) = g(x)−x. Equivalently, the root of&nbsp;<strong>ff</strong>&nbsp;is the fixed_point of g(x) = f(x)+x. The routine fixed_point provides a simple iterative method using the&nbsp;<strong>Aitkens sequence acceleration</strong>&nbsp;to estimate the fixed point of&nbsp;<strong>gg</strong>, if a starting point is given.</p>\n\n\n\n<h3>Sets of equations</h3>\n\n\n\n<p>Finding a root of a set of non-linear equations can be achieved using the&nbsp;<strong>root() function</strong>. Several methods are available, amongst which&nbsp;<strong>hybr</strong>&nbsp;(the default) and lm, respectively use the&nbsp;<strong>hybrid method of Powell</strong>&nbsp;and the&nbsp;<strong>Levenberg-Marquardt method</strong>&nbsp;from the MINPACK.</p>\n\n\n\n<p>The following example considers the single-variable transcendental equation.</p>\n\n\n\n<p><strong>x<sup>2</sup>&nbsp;+ 2cos(x) = 0</strong></p>\n\n\n\n<p>A root of which can be found as follows −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import numpy as np\nfrom scipy.optimize import root\ndef func(x):\n   return x*2 + 2 * np.cos(x)\nsol = root(func, 0.3)\nprint sol</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>fjac: array(&#91;&#91;-1.]])\nfun: array(&#91; 2.22044605e-16])\nmessage: 'The solution converged.'\n   nfev: 10\n   qtf: array(&#91; -2.77644574e-12])\n      r: array(&#91;-3.34722409])\n   status: 1\n   success: True\n      x: array(&#91;-0.73908513])</code></pre>\n","protected":false},"excerpt":{"rendered":"<p>The&nbsp;scipy.optimize package&nbsp;provides several commonly used optimization algorithms. This module contains the following aspects − Unconstrained and constrained minimization of multivariate scalar functions (minimize()) using a variety of algorithms (e.g. BFGS, Nelder-Mead simplex, Newton Conjugate Gradient, COBYLA or SLSQP) Global (brute-force) optimization routines (e.g., anneal(), basinhopping()) Least-squares minimization (leastsq()) and curve fitting (curve_fit()) algorithms Scalar univariate [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[100,154],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3869"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3869"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3869/revisions"}],"predecessor-version":[{"id":4208,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3869/revisions/4208"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3869"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3869"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3869"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3870,"date":"2020-09-09T05:45:27","date_gmt":"2020-09-09T05:45:27","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=2066"},"modified":"2020-12-16T17:01:15","modified_gmt":"2020-12-16T17:01:15","slug":"scipy-stats","status":"publish","type":"post","link":"https://python3.foobrdigital.com/scipy-stats/","title":{"rendered":"SciPy &#8211; Stats"},"content":{"rendered":"\n<p>All of the statistics functions are located in the sub-package&nbsp;<strong>scipy.stats</strong>&nbsp;and a fairly complete listing of these functions can be obtained using&nbsp;<strong>info(stats)</strong>&nbsp;function. A list of random variables available can also be obtained from the&nbsp;<strong>docstring</strong>&nbsp;for the stats sub-package. This module contains a large number of probability distributions as well as a growing library of statistical functions.</p>\n\n\n\n<p>Each univariate distribution has its own subclass as described in the following table −</p>\n\n\n\n<figure class=\"wp-block-table\"><table><tbody><tr><th>Sr. No.</th><th>Class &amp; Description</th></tr><tr><td>1</td><td><strong>rv_continuous</strong>A generic continuous random variable class meant for subclassing</td></tr><tr><td>2</td><td><strong>rv_discrete</strong>A generic discrete random variable class meant for subclassing</td></tr><tr><td>3</td><td><strong>rv_histogram</strong>Generates a distribution given by a histogram</td></tr></tbody></table></figure>\n\n\n\n<h2>Normal Continuous Random Variable</h2>\n\n\n\n<p>A probability distribution in which the random variable X can take any value is continuous random variable. The location (loc) keyword specifies the mean. The scale (scale) keyword specifies the standard deviation.</p>\n\n\n\n<p>As an instance of the&nbsp;<strong>rv_continuous</strong>&nbsp;class,&nbsp;<strong>norm</strong>&nbsp;object inherits from it a collection of generic methods and completes them with details specific for this particular distribution.</p>\n\n\n\n<p>To compute the CDF at a number of points, we can pass a list or a NumPy array. Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.stats import norm\nimport numpy as np\nprint norm.cdf(np.array(&#91;1,-1., 0, 1, 3, 4, -2, 6]))\n</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>array(&#91; 0.84134475, 0.15865525, 0.5 , 0.84134475, 0.9986501 ,\n0.99996833, 0.02275013, 1. ])\n</code></pre>\n\n\n\n<p>To find the median of a distribution, we can use the Percent Point Function (PPF), which is the inverse of the CDF. Let us understand by using the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.stats import norm\nprint norm.ppf(0.5)\n</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>0.0\n</code></pre>\n\n\n\n<p>To generate a sequence of random variates, we should use the size keyword argument, which is shown in the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.stats import norm\nprint norm.rvs(size = 5)\n</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>array(&#91; 0.20929928, -1.91049255, 0.41264672, -0.7135557 , -0.03833048])\n</code></pre>\n\n\n\n<p>The above output is not reproducible. To generate the same random numbers, use the seed function.</p>\n\n\n\n<h2>Uniform Distribution</h2>\n\n\n\n<p>A uniform distribution can be generated using the uniform function. Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.stats import uniform\nprint uniform.cdf(&#91;0, 1, 2, 3, 4, 5], loc = 1, scale = 4)\n</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>array(&#91; 0. , 0. , 0.25, 0.5 , 0.75, 1. ])\n</code></pre>\n\n\n\n<h3>Build Discrete Distribution</h3>\n\n\n\n<p>Let us generate a random sample and compare the observed frequencies with the probabilities.</p>\n\n\n\n<h3>Binomial Distribution</h3>\n\n\n\n<p>As an instance of the&nbsp;<strong>rv_discrete class</strong>, the&nbsp;<strong>binom object</strong>&nbsp;inherits from it a collection of generic methods and completes them with details specific for this particular distribution. Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.stats import uniform\nprint uniform.cdf(&#91;0, 1, 2, 3, 4, 5], loc = 1, scale = 4)\n</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>array(&#91; 0. , 0. , 0.25, 0.5 , 0.75, 1. ])\n</code></pre>\n\n\n\n<h2>Descriptive Statistics</h2>\n\n\n\n<p>The basic stats such as Min, Max, Mean and Variance takes the NumPy array as input and returns the respective results. A few basic statistical functions available in the&nbsp;<strong>scipy.stats package</strong>&nbsp;are described in the following table.</p>\n\n\n\n<figure class=\"wp-block-table\"><table><tbody><tr><th>Sr. No.</th><th>Function &amp; Description</th></tr><tr><td>1</td><td><strong>describe()</strong>Computes several descriptive statistics of the passed array</td></tr><tr><td>2</td><td><strong>gmean()</strong>Computes geometric mean along the specified axis</td></tr><tr><td>3</td><td><strong>hmean()</strong>Calculates the harmonic mean along the specified axis</td></tr><tr><td>4</td><td><strong>kurtosis()</strong>Computes the kurtosis</td></tr><tr><td>5</td><td><strong>mode()</strong>Returns the modal value</td></tr><tr><td>6</td><td><strong>skew()</strong>Tests the skewness of the data</td></tr><tr><td>7</td><td><strong>f_oneway()</strong>Performs a 1-way ANOVA</td></tr><tr><td>8</td><td><strong>iqr()</strong>Computes the interquartile range of the data along the specified axis</td></tr><tr><td>9</td><td><strong>zscore()</strong>Calculates the z score of each value in the sample, relative to the sample mean and standard deviation</td></tr><tr><td>10</td><td><strong>sem()</strong>Calculates the standard error of the mean (or standard error of measurement) of the values in the input array</td></tr></tbody></table></figure>\n\n\n\n<p>Several of these functions have a similar version in the&nbsp;<strong>scipy.stats.mstats</strong>, which work for masked arrays. Let us understand this with the example given below.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy import stats\nimport numpy as np\nx = np.array(&#91;1,2,3,4,5,6,7,8,9])\nprint x.max(),x.min(),x.mean(),x.var()</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>(9, 1, 5.0, 6.666666666666667)\n</code></pre>\n\n\n\n<h2>T-test</h2>\n\n\n\n<p>Let us understand how T-test is useful in SciPy.</p>\n\n\n\n<h3>ttest_1samp</h3>\n\n\n\n<p>Calculates the T-test for the mean of ONE group of scores. This is a two-sided test for the null hypothesis that the expected value (mean) of a sample of independent observations ‘a’ is equal to the given population mean,&nbsp;<strong>popmean</strong>. Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy import stats\nrvs = stats.norm.rvs(loc = 5, scale = 10, size = (50,2))\nprint stats.ttest_1samp(rvs,5.0)</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>Ttest_1sampResult(statistic = array(&#91;-1.40184894, 2.70158009]),\npvalue = array(&#91; 0.16726344, 0.00945234]))\n</code></pre>\n\n\n\n<h3>Comparing two samples</h3>\n\n\n\n<p>In the following examples, there are two samples, which can come either from the same or from different distribution, and we want to test whether these samples have the same statistical properties.</p>\n\n\n\n<p><strong>ttest_ind</strong>&nbsp;− Calculates the T-test for the means of two independent samples of scores. This is a two-sided test for the null hypothesis that two independent samples have identical average (expected) values. This test assumes that the populations have identical variances by default.</p>\n\n\n\n<p>We can use this test, if we observe two independent samples from the same or different population. Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy import stats\nrvs1 = stats.norm.rvs(loc = 5,scale = 10,size = 500)\nrvs2 = stats.norm.rvs(loc = 5,scale = 10,size = 500)\nprint stats.ttest_ind(rvs1,rvs2)</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>Ttest_indResult(statistic = -0.67406312233650278, pvalue = 0.50042727502272966)\n</code></pre>\n\n\n\n<p>You can test the same with a new array of the same length, but with a varied mean. Use a different value in&nbsp;<strong>loc</strong>&nbsp;and test the same.</p>\n","protected":false},"excerpt":{"rendered":"<p>All of the statistics functions are located in the sub-package&nbsp;scipy.stats&nbsp;and a fairly complete listing of these functions can be obtained using&nbsp;info(stats)&nbsp;function. A list of random variables available can also be obtained from the&nbsp;docstring&nbsp;for the stats sub-package. This module contains a large number of probability distributions as well as a growing library of statistical functions. Each [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[100,154],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3870"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3870"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3870/revisions"}],"predecessor-version":[{"id":4207,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3870/revisions/4207"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3870"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3870"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3870"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3871,"date":"2020-09-09T05:47:56","date_gmt":"2020-09-09T05:47:56","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=2068"},"modified":"2020-12-16T17:01:15","modified_gmt":"2020-12-16T17:01:15","slug":"scipy-csgraph","status":"publish","type":"post","link":"https://python3.foobrdigital.com/scipy-csgraph/","title":{"rendered":"SciPy &#8211; CSGraph"},"content":{"rendered":"\n<p>CSGraph stands for&nbsp;<strong>Compressed Sparse Graph</strong>, which focuses on Fast graph algorithms based on sparse matrix representations.</p>\n\n\n\n<h2>Graph Representations</h2>\n\n\n\n<p>To begin with, let us understand what a sparse graph is and how it helps in graph representations.</p>\n\n\n\n<h3>What exactly is a sparse graph?</h3>\n\n\n\n<p>A graph is just a collection of nodes, which have links between them. Graphs can represent nearly anything − social network connections, where each node is a person and is connected to acquaintances; images, where each node is a pixel and is connected to neighboring pixels; points in a high-dimensional distribution, where each node is connected to its nearest neighbors; and practically anything else you can imagine.</p>\n\n\n\n<p>One very efficient way to represent graph data is in a sparse matrix: let us call it G. The matrix G is of size N x N, and G[i, j] gives the value of the connection between node ‘i&#8217; and node ‘j’. A sparse graph contains mostly zeros − that is, most nodes have only a few connections. This property turns out to be true in most cases of interest.</p>\n\n\n\n<p>The creation of the sparse graph submodule was motivated by several algorithms used in scikit-learn that included the following −</p>\n\n\n\n<ul><li><strong>Isomap</strong>&nbsp;− A manifold learning algorithm, which requires finding the shortest paths in a graph.</li><li><strong>Hierarchical clustering</strong>&nbsp;− A clustering algorithm based on a minimum spanning tree.</li><li><strong>Spectral Decomposition</strong>&nbsp;− A projection algorithm based on sparse graph laplacians.</li></ul>\n\n\n\n<p>As a concrete example, imagine that we would like to represent the following undirected graph −</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/scipy/images/undirected_graph.jpg\" alt=\"Undirected Graph\"/></figure>\n\n\n\n<p>This graph has three nodes, where node 0 and 1 are connected by an edge of weight 2, and nodes 0 and 2 are connected by an edge of weight 1. We can construct the dense, masked and sparse representations as shown in the following example, keeping in mind that an undirected graph is represented by a symmetric matrix.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>G_dense = np.array(&#91; &#91;0, 2, 1],\n                     &#91;2, 0, 0],\n                     &#91;1, 0, 0] ])\n                     \nG_masked = np.ma.masked_values(G_dense, 0)\nfrom scipy.sparse import csr_matrix\n\nG_sparse = csr_matrix(G_dense)\nprint G_sparse.data</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>array(&#91;2, 1, 2, 1])\n</code></pre>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/scipy/images/undirected_graph_using_symmetric_matrix.jpg\" alt=\"Undirected Graph Using Symmetric Matrix\"/></figure>\n\n\n\n<p>This is identical to the previous graph, except nodes 0 and 2 are connected by an edge of zero weight. In this case, the dense representation above leads to ambiguities − how can non-edges be represented, if zero is a meaningful value. In this case, either a masked or a sparse representation must be used to eliminate the ambiguity.</p>\n\n\n\n<p>Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.sparse.csgraph import csgraph_from_dense\nG2_data = np.array\n(&#91;\n   &#91;np.inf, 2, 0 ],\n   &#91;2, np.inf, np.inf],\n   &#91;0, np.inf, np.inf]\n])\nG2_sparse = csgraph_from_dense(G2_data, null_value=np.inf)\nprint G2_sparse.data</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>array(&#91; 2., 0., 2., 0.])\n</code></pre>\n\n\n\n<h3>Word ladders using sparse graphs</h3>\n\n\n\n<p>Word ladders is a game invented by Lewis Carroll, in which words are linked by changing a single letter at each step. For example −</p>\n\n\n\n<p><strong>APE → APT → AIT → BIT → BIG → BAG → MAG → MAN</strong></p>\n\n\n\n<p>Here, we have gone from &#8220;APE&#8221; to &#8220;MAN&#8221; in seven steps, changing one letter each time. The question is &#8211; Can we find a shorter path between these words using the same rule? This problem is naturally expressed as a sparse graph problem. The nodes will correspond to individual words, and we will create connections between words that differ by at the most – one letter.</p>\n\n\n\n<h2>Obtaining a List of Words</h2>\n\n\n\n<p>First, of course, we must obtain a list of valid words. I am running Mac, and Mac has a word dictionary at the location given in the following code block. If you are on a different architecture, you may have to search a bit to find your system dictionary.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>wordlist = open('/usr/share/dict/words').read().split()\nprint len(wordlist)</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>235886\n</code></pre>\n\n\n\n<p>We now want to look at words of length 3, so let us select just those words of the correct length. We will also eliminate words, which start with upper case (proper nouns) or contain non-alpha-numeric characters such as apostrophes and hyphens. Finally, we will make sure everything is in lower case for a comparison later on.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>word_list = &#91;word for word in word_list if len(word) == 3]\nword_list = &#91;word for word in word_list if word&#91;0].islower()]\nword_list = &#91;word for word in word_list if word.isalpha()]\nword_list = map(str.lower, word_list)\nprint len(word_list)</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>1135\n</code></pre>\n\n\n\n<p>Now, we have a list of 1135 valid three-letter words (the exact number may change depending on the particular list used). Each of these words will become a node in our graph, and we will create edges connecting the nodes associated with each pair of words, which differs by only one letter.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import numpy as np\nword_list = np.asarray(word_list)\n\nword_list.dtype\nword_list.sort()\n\nword_bytes = np.ndarray((word_list.size, word_list.itemsize),\n   dtype = 'int8',\n   buffer = word_list.data)\nprint word_bytes.shape</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>(1135, 3)\n</code></pre>\n\n\n\n<p>We will use the Hamming distance between each point to determine, which pairs of words are connected. The Hamming distance measures the fraction of entries between two vectors, which differ: any two words with a hamming distance equal to 1/N1/N, where NN is the number of letters, which are connected in the word ladder.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.spatial.distance import pdist, squareform\nfrom scipy.sparse import csr_matrix\nhamming_dist = pdist(word_bytes, metric = 'hamming')\ngraph = csr_matrix(squareform(hamming_dist &lt; 1.5 / word_list.itemsize))\n</code></pre>\n\n\n\n<p>When comparing the distances, we do not use equality because this can be unstable for floating point values. The inequality produces the desired result as long as no two entries of the word list are identical. Now, that our graph is set up, we will use the shortest path search to find the path between any two words in the graph.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>i1 = word_list.searchsorted('ape')\ni2 = word_list.searchsorted('man')\nprint word_list&#91;i1],word_list&#91;i2]</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>ape, man\n</code></pre>\n\n\n\n<p>We need to check that these match, because if the words are not in the list there will be an error in the output. Now, all we need is to find the shortest path between these two indices in the graph. We will use&nbsp;<strong>dijkstra’s</strong>&nbsp;algorithm, because it allows us to find the path for just one node.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.sparse.csgraph import dijkstra\ndistances, predecessors = dijkstra(graph, indices = i1, return_predecessors = True)\nprint distances&#91;i2]</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>5.0\n</code></pre>\n\n\n\n<p>Thus, we see that the shortest path between ‘ape’ and ‘man’ contains only five steps. We can use the predecessors returned by the algorithm to reconstruct this path.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>path = &#91;]\ni = i2\n\nwhile i != i1:\n   path.append(word_list&#91;i])\n   i = predecessors&#91;i]\n   \npath.append(word_list&#91;i1])\nprint path&#91;::-1]i2]</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&#91;'ape', 'ope', 'opt', 'oat', 'mat', 'man']</code></pre>\n","protected":false},"excerpt":{"rendered":"<p>CSGraph stands for&nbsp;Compressed Sparse Graph, which focuses on Fast graph algorithms based on sparse matrix representations. Graph Representations To begin with, let us understand what a sparse graph is and how it helps in graph representations. What exactly is a sparse graph? A graph is just a collection of nodes, which have links between them. [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[100,154],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3871"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3871"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3871/revisions"}],"predecessor-version":[{"id":4206,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3871/revisions/4206"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3871"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3871"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3871"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3872,"date":"2020-09-09T05:49:45","date_gmt":"2020-09-09T05:49:45","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=2071"},"modified":"2020-12-16T17:01:15","modified_gmt":"2020-12-16T17:01:15","slug":"scipy-spatial","status":"publish","type":"post","link":"https://python3.foobrdigital.com/scipy-spatial/","title":{"rendered":"SciPy &#8211; Spatial"},"content":{"rendered":"\n<p>The&nbsp;<strong>scipy.spatial package</strong>&nbsp;can compute Triangulations, Voronoi Diagrams and Convex Hulls of a set of points, by leveraging the&nbsp;<strong>Qhull library</strong>. Moreover, it contains&nbsp;<strong>KDTree implementations</strong>&nbsp;for nearest-neighbor point queries and utilities for distance computations in various metrics.</p>\n\n\n\n<h2>Delaunay Triangulations</h2>\n\n\n\n<p>Let us understand what Delaunay Triangulations are and how they are used in SciPy.</p>\n\n\n\n<h3>What are Delaunay Triangulations?</h3>\n\n\n\n<p>In mathematics and computational geometry, a Delaunay triangulation for a given set&nbsp;<strong>P</strong>&nbsp;of discrete points in a plane is a triangulation&nbsp;<strong>DT(P)</strong>&nbsp;such that no point in&nbsp;<strong>P</strong>&nbsp;is inside the circumcircle of any triangle in DT(P).</p>\n\n\n\n<p>We can the compute the same through SciPy. Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.spatial import Delaunay\npoints = np.array(&#91;&#91;0, 4], &#91;2, 1.1], &#91;1, 3], &#91;1, 2]])\ntri = Delaunay(points)\nimport matplotlib.pyplot as plt\nplt.triplot(points&#91;:,0], points&#91;:,1], tri.simplices.copy())\nplt.plot(points&#91;:,0], points&#91;:,1], 'o')\nplt.show()</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/scipy/images/delaunay_triangulations.jpg\" alt=\"Delaunay Triangulations\"/></figure>\n\n\n\n<h2>Coplanar Points</h2>\n\n\n\n<p>Let us understand what Coplanar Points are and how they are used in SciPy.</p>\n\n\n\n<h3>What are Coplanar Points?</h3>\n\n\n\n<p>Coplanar points are three or more points that lie in the same plane. Recall that a plane is a flat surface, which extends without end in all directions. It is usually shown in math textbooks as a four-sided figure.</p>\n\n\n\n<p>Let us see how we can find this using SciPy. Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.spatial import Delaunay\npoints = np.array(&#91;&#91;0, 0], &#91;0, 1], &#91;1, 0], &#91;1, 1], &#91;1, 1]])\ntri = Delaunay(points)\nprint tri.coplanar</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>array(&#91;&#91;4, 0, 3]], dtype = int32)\n</code></pre>\n\n\n\n<p>This means that point 4 resides near triangle 0 and vertex 3, but is not included in the triangulation.</p>\n\n\n\n<h2>Convex hulls</h2>\n\n\n\n<p>Let us understand what convex hulls are and how they are used in SciPy.</p>\n\n\n\n<h3>What are Convex Hulls?</h3>\n\n\n\n<p>In mathematics, the&nbsp;<strong>convex hull</strong>&nbsp;or&nbsp;<strong>convex envelope</strong>&nbsp;of a set of points X in the Euclidean plane or in a Euclidean space (or, more generally, in an affine space over the reals) is the smallest&nbsp;<strong>convex set</strong>&nbsp;that contains X.</p>\n\n\n\n<p>Let us consider the following example to understand it in detail.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.spatial import ConvexHull\npoints = np.random.rand(10, 2) # 30 random points in 2-D\nhull = ConvexHull(points)\nimport matplotlib.pyplot as plt\nplt.plot(points&#91;:,0], points&#91;:,1], 'o')\nfor simplex in hull.simplices:\nplt.plot(points&#91;simplex,0], points&#91;simplex,1], 'k-')\nplt.show()</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/scipy/images/convex_hulls.jpg\" alt=\"Convex Hulls\"/></figure>\n","protected":false},"excerpt":{"rendered":"<p>The&nbsp;scipy.spatial package&nbsp;can compute Triangulations, Voronoi Diagrams and Convex Hulls of a set of points, by leveraging the&nbsp;Qhull library. Moreover, it contains&nbsp;KDTree implementations&nbsp;for nearest-neighbor point queries and utilities for distance computations in various metrics. Delaunay Triangulations Let us understand what Delaunay Triangulations are and how they are used in SciPy. What are Delaunay Triangulations? In mathematics [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[100,154],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3872"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3872"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3872/revisions"}],"predecessor-version":[{"id":4205,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3872/revisions/4205"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3872"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3872"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3872"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3873,"date":"2020-09-09T05:50:52","date_gmt":"2020-09-09T05:50:52","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=2073"},"modified":"2020-12-16T17:01:15","modified_gmt":"2020-12-16T17:01:15","slug":"scipy-odr","status":"publish","type":"post","link":"https://python3.foobrdigital.com/scipy-odr/","title":{"rendered":"SciPy &#8211; ODR"},"content":{"rendered":"\n<p>ODR stands for&nbsp;<strong>Orthogonal Distance Regression</strong>, which is used in the regression studies. Basic linear regression is often used to estimate the relationship between the two variables&nbsp;<strong>y</strong>&nbsp;and&nbsp;<strong>x</strong>&nbsp;by drawing the line of best fit on the graph.</p>\n\n\n\n<p>The mathematical method that is used for this is known as&nbsp;<strong>Least Squares</strong>, and aims to minimize the sum of the squared error for each point. The key question here is how do you calculate the error (also known as the residual) for each point?</p>\n\n\n\n<p>In a standard linear regression, the aim is to predict the Y value from the X value – so the sensible thing to do is to calculate the error in the Y values (shown as the gray lines in the following image). However, sometimes it is more sensible to take into account the error in both X and Y (as shown by the dotted red lines in the following image).</p>\n\n\n\n<p>For example − When you know your measurements of X are uncertain, or when you do not want to focus on the errors of one variable over another.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/scipy/images/orthogonal_distance_linear_regression.jpg\" alt=\"Orthogonal Distance linear regression\"/></figure>\n\n\n\n<p>Orthogonal Distance Regression (ODR) is a method that can do this (orthogonal in this context means perpendicular – so it calculates errors perpendicular to the line, rather than just ‘vertically’).</p>\n\n\n\n<h3>scipy.odr Implementation for Univariate Regression</h3>\n\n\n\n<p>The following example demonstrates scipy.odr implementation for univariate regression.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.odr import *\nimport random\n\n# Initiate some data, giving some randomness using random.random().\nx = np.array(&#91;0, 1, 2, 3, 4, 5])\ny = np.array(&#91;i**2 + random.random() for i in x])\n\n# Define a function (quadratic in our case) to fit the data with.\ndef linear_func(p, x):\n   m, c = p\n   return m*x + c\n\n# Create a model for fitting.\nlinear_model = Model(linear_func)\n\n# Create a RealData object using our initiated data from above.\ndata = RealData(x, y)\n\n# Set up ODR with the model and data.\nodr = ODR(data, linear_model, beta0=&#91;0., 1.])\n\n# Run the regression.\nout = odr.run()\n\n# Use the in-built pprint method to give us results.\nout.pprint()</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>Beta: &#91; 5.51846098 -4.25744878]\nBeta Std Error: &#91; 0.7786442 2.33126407]\n\nBeta Covariance: &#91;\n   &#91; 1.93150969 -4.82877433]\n   &#91; -4.82877433 17.31417201\n]]\n\nResidual Variance: 0.313892697582\nInverse Condition #: 0.146618499389\nReason(s) for Halting:\n   Sum of squares convergence</code></pre>\n","protected":false},"excerpt":{"rendered":"<p>ODR stands for&nbsp;Orthogonal Distance Regression, which is used in the regression studies. Basic linear regression is often used to estimate the relationship between the two variables&nbsp;y&nbsp;and&nbsp;x&nbsp;by drawing the line of best fit on the graph. The mathematical method that is used for this is known as&nbsp;Least Squares, and aims to minimize the sum of the [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[100,154],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3873"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3873"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3873/revisions"}],"predecessor-version":[{"id":4204,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3873/revisions/4204"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3873"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3873"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3873"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3874,"date":"2020-09-09T05:53:35","date_gmt":"2020-09-09T05:53:35","guid":{"rendered":"http://learnpython.foobrdigital.com/?p=2075"},"modified":"2020-12-16T17:01:15","modified_gmt":"2020-12-16T17:01:15","slug":"scipy-special-package","status":"publish","type":"post","link":"https://python3.foobrdigital.com/scipy-special-package/","title":{"rendered":"SciPy &#8211; Special Package"},"content":{"rendered":"\n<p>The functions available in the special package are universal functions, which follow broadcasting and automatic array looping.</p>\n\n\n\n<p>Let us look at some of the most frequently used special functions −</p>\n\n\n\n<ul><li>Cubic Root Function</li><li>Exponential Function</li><li>Relative Error Exponential Function</li><li>Log Sum Exponential Function</li><li>Lambert Function</li><li>Permutations and Combinations Function</li><li>Gamma Function</li></ul>\n\n\n\n<p>Let us now understand each of these functions in brief.</p>\n\n\n\n<h3>Cubic Root Function</h3>\n\n\n\n<p>The syntax of this cubic root function is – scipy.special.cbrt(x). This will fetch the element-wise cube root of&nbsp;<strong>x</strong>.</p>\n\n\n\n<p>Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.special import cbrt\nres = cbrt(&#91;10, 9, 0.1254, 234])\nprint res</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&#91; 2.15443469 2.08008382 0.50053277 6.16224015]\n</code></pre>\n\n\n\n<h3>Exponential Function</h3>\n\n\n\n<p>The syntax of the exponential function is – scipy.special.exp10(x). This will compute 10**x element wise.</p>\n\n\n\n<p>Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.special import exp10\nres = exp10(&#91;2, 9])\nprint res</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&#91;1.00000000e+02  1.00000000e+09]\n</code></pre>\n\n\n\n<h3>Relative Error Exponential Function</h3>\n\n\n\n<p>The syntax for this function is – scipy.special.exprel(x). It generates the relative error exponential, (exp(x) &#8211; 1)/x.</p>\n\n\n\n<p>When&nbsp;<strong>x</strong>&nbsp;is near zero, exp(x) is near 1, so the numerical calculation of exp(x) &#8211; 1 can suffer from catastrophic loss of precision. Then exprel(x) is implemented to avoid the loss of precision, which occurs when&nbsp;<strong>x</strong>&nbsp;is near zero.</p>\n\n\n\n<p>Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.special import exprel\nres = exprel(&#91;-0.25, -0.1, 0, 0.1, 0.25])\nprint res</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&#91;0.88479687 0.95162582 1.   1.05170918 1.13610167]\n</code></pre>\n\n\n\n<h3>Log Sum Exponential Function</h3>\n\n\n\n<p>The syntax for this function is – scipy.special.logsumexp(x). It helps to compute the log of the sum of exponentials of input elements.</p>\n\n\n\n<p>Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.special import logsumexp\nimport numpy as np\na = np.arange(10)\nres = logsumexp(a)\nprint res</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>9.45862974443\n</code></pre>\n\n\n\n<h3>Lambert Function</h3>\n\n\n\n<p>The syntax for this function is – scipy.special.lambertw(x). It is also called as the Lambert W function. The Lambert W function W(z) is defined as the inverse function of w * exp(w). In other words, the value of W(z) is such that z = W(z) * exp(W(z)) for any complex number z.</p>\n\n\n\n<p>The Lambert W function is a multivalued function with infinitely many branches. Each branch gives a separate solution of the equation z = w exp(w). Here, the branches are indexed by the integer k.</p>\n\n\n\n<p>Let us consider the following example. Here, the Lambert W function is the inverse of w exp(w).</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.special import lambertw\nw = lambertw(1)\nprint w\nprint w * np.exp(w)</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>(0.56714329041+0j)\n(1+0j)\n</code></pre>\n\n\n\n<h3>Permutations &amp; Combinations</h3>\n\n\n\n<p>Let us discuss permutations and combinations separately for understanding them clearly.</p>\n\n\n\n<p><strong>Combinations</strong>&nbsp;− The syntax for combinations function is – scipy.special.comb(N,k). Let us consider the following example −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.special import comb\nres = comb(10, 3, exact = False,repetition=True)\nprint res</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>220.0\n</code></pre>\n\n\n\n<p><strong>Note</strong>&nbsp;− Array arguments are accepted only for exact = False case. If k &gt; N, N &lt; 0, or k &lt; 0, then a 0 is returned.</p>\n\n\n\n<p><strong>Permutations</strong>&nbsp;− The syntax for combinations function is – scipy.special.perm(N,k). Permutations of N things taken k at a time, i.e., k-permutations of N. This is also known as “partial permutations”.</p>\n\n\n\n<p>Let us consider the following example.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.special import perm\nres = perm(10, 3, exact = True)\nprint res</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>720\n</code></pre>\n\n\n\n<h3>Gamma Function</h3>\n\n\n\n<p>The gamma function is often referred to as the generalized factorial since z*gamma(z) = gamma(z+1) and gamma(n+1) = n!, for a natural number ‘n’.</p>\n\n\n\n<p>The syntax for combinations function is – scipy.special.gamma(x). Permutations of N things taken k at a time, i.e., k-permutations of N. This is also known as “partial permutations”.</p>\n\n\n\n<p>The syntax for combinations function is – scipy.special.gamma(x). Permutations of N things taken k at a time, i.e., k-permutations of N. This is also known as “partial permutations”.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from scipy.special import gamma\nres = gamma(&#91;0, 0.5, 1, 5])\nprint res</code></pre>\n\n\n\n<p>The above program will generate the following output.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&#91;inf  1.77245385  1.  24.]</code></pre>\n","protected":false},"excerpt":{"rendered":"<p>The functions available in the special package are universal functions, which follow broadcasting and automatic array looping. Let us look at some of the most frequently used special functions − Cubic Root Function Exponential Function Relative Error Exponential Function Log Sum Exponential Function Lambert Function Permutations and Combinations Function Gamma Function Let us now understand [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[100,154],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3874"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3874"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3874/revisions"}],"predecessor-version":[{"id":4203,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3874/revisions/4203"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3874"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3874"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3874"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}}]