[{"id":3348,"date":"2020-10-01T10:26:29","date_gmt":"2020-10-01T10:26:29","guid":{"rendered":"http://ai.foobrdigital.com/?p=3348"},"modified":"2020-12-25T08:28:13","modified_gmt":"2020-12-25T08:28:13","slug":"caffe2-introduction","status":"publish","type":"post","link":"https://python3.foobrdigital.com/caffe2-introduction/","title":{"rendered":"Introduction"},"content":{"rendered":"\n<p>Last couple of years, Deep Learning has become a big trend in Machine Learning. It has been successfully applied to solve previously unsolvable problems in&nbsp;<strong>Vision, Speech Recognition and Natural Language Processing</strong>&nbsp;(NLP). There are many more domains in which Deep Learning is being applied and has shown its usefulness.</p>\n\n\n\n<p><strong>Caffe (Convolutional Architecture for Fast Feature Embedding)</strong>&nbsp;is a deep learning framework developed at&nbsp;<strong>Berkeley Vision and Learning Center (BVLC)</strong>. The Caffe project was created by Yangqing Jia during his Ph.D. at University of California &#8211; Berkeley. Caffe provides an easy way to experiment with deep learning. It is written in C++ and provides bindings for&nbsp;<strong>Python</strong>&nbsp;and&nbsp;<strong>Matlab</strong>.</p>\n\n\n\n<p>It supports many different types of deep learning architectures such as&nbsp;<strong>CNN</strong>&nbsp;(Convolutional Neural Network),&nbsp;<strong>LSTM</strong>&nbsp;(Long Short Term Memory) and FC (Fully Connected). It supports GPU and is thus, ideally suited for production environments involving deep neural networks. It also supports CPU-based kernel libraries such as&nbsp;<strong>NVIDIA</strong>, CUDA Deep Neural Network library&nbsp;<strong>(cuDNN)</strong>&nbsp;and Intel Math Kernel Library&nbsp;<strong>(Intel MKL)</strong>.</p>\n\n\n\n<p>In April 2017, U.S. based social networking service company Facebook announced Caffe2, which now includes RNN (Recurrent Neural Networks) and in March 2018, Caffe2 was merged into PyTorch. Caffe2 creators and community members have created models for solving various problems. These models are available to the public as pre-trained models. Caffe2 helps the creators in using these models and creating one’s own network for making predictions on the dataset.</p>\n\n\n\n<p>Before we go into the details of Caffe2, let us understand the difference between&nbsp;<strong>machine learning</strong>&nbsp;and&nbsp;<strong>deep learning</strong>. This is necessary to understand how models are created and used in Caffe2.</p>\n\n\n\n<h2>Machine Learning v/s Deep Learning</h2>\n\n\n\n<p>In any machine learning algorithm, be it a traditional one or a deep learning one, the selection of features in the dataset plays an extremely important role in getting the desired prediction accuracy. In traditional machine learning techniques, the&nbsp;<strong>feature selection</strong>&nbsp;is done mostly by human inspection, judgement and deep domain knowledge. Sometimes, you may seek help from a few tested algorithms for feature selection.</p>\n\n\n\n<p>The traditional machine learning flow is depicted in the figure below −</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/caffe2/images/machine_learning.jpg\" alt=\"Machine Learning\"/></figure>\n\n\n\n<p>In deep learning, the feature selection is automatic and is a part of deep learning algorithm itself. This is shown in the figure below −</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/caffe2/images/deep_learning.jpg\" alt=\"Deep Learning\"/></figure>\n\n\n\n<p>In deep learning algorithms,&nbsp;<strong>feature engineering</strong>&nbsp;is done automatically. Generally, feature engineering is time-consuming and requires a good expertise in domain. To implement the automatic feature extraction, the deep learning algorithms typically ask for huge amount of data, so if you have only thousands and tens of thousands of data points, the deep learning technique may fail to give you satisfactory results.</p>\n\n\n\n<p>With larger data, the deep learning algorithms produce better results compared to traditional ML algorithms with an added advantage of less or no feature engineering.</p>\n","protected":false},"excerpt":{"rendered":"<p>Last couple of years, Deep Learning has become a big trend in Machine Learning. It has been successfully applied to solve previously unsolvable problems in&nbsp;Vision, Speech Recognition and Natural Language Processing&nbsp;(NLP). There are many more domains in which Deep Learning is being applied and has shown its usefulness. Caffe (Convolutional Architecture for Fast Feature Embedding)&nbsp;is [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[90,156],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3348"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3348"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3348/revisions"}],"predecessor-version":[{"id":4368,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3348/revisions/4368"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3348"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3348"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3348"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3350,"date":"2020-10-01T10:27:04","date_gmt":"2020-10-01T10:27:04","guid":{"rendered":"http://ai.foobrdigital.com/?p=3350"},"modified":"2020-12-25T08:28:13","modified_gmt":"2020-12-25T08:28:13","slug":"overview-5","status":"publish","type":"post","link":"https://python3.foobrdigital.com/overview-5/","title":{"rendered":"Overview"},"content":{"rendered":"\n<p>Now, as you have got some insights into deep learning, let us get an overview of what is Caffe.</p>\n\n\n\n<h2>Training a CNN</h2>\n\n\n\n<p>Let us learn the process for training a CNN for classifying images. The process consists of the following steps −</p>\n\n\n\n<ul><li><strong>Data Preparation</strong>&nbsp;− In this step, we center-crop the images and resize them so that all images for training and testing would be of the same size. This is usually done by running a small Python script on the image data.</li><li><strong>Model Definition</strong>&nbsp;− In this step, we define a CNN architecture. The configuration is stored in&nbsp;<strong>.pb (protobuf)</strong>&nbsp;file. A typical CNN architecture is shown in figure below.</li><li><strong>Solver Definition</strong>&nbsp;− We define the solver configuration file. Solver does the model optimization.</li><li><strong>Model Training</strong>&nbsp;− We use the built-in Caffe utility to train the model. The training may take a considerable amount of time and CPU usage. After the training is completed, Caffe stores the model in a file, which can later on be used on test data and final deployment for predictions.</li></ul>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/caffe2/images/training_cnn.jpg\" alt=\"Training CNN\"/></figure>\n\n\n\n<h2>What’s New in Caffe2</h2>\n\n\n\n<p>In Caffe2, you would find many ready-to-use pre-trained models and also leverage the community contributions of new models and algorithms quite frequently. The models that you create can scale up easily using the GPU power in the cloud and also can be brought down to the use of masses on mobile with its cross-platform libraries.</p>\n\n\n\n<p>The improvements made in Caffe2 over Caffe may be summarized as follows −</p>\n\n\n\n<ul><li>Mobile deployment</li><li>New hardware support</li><li>Support for large-scale distributed training</li><li>Quantized computation</li><li>Stress tested on Facebook</li></ul>\n\n\n\n<h3>Pretrained Model Demo</h3>\n\n\n\n<p>The Berkeley Vision and Learning Center (BVLC) site provides demos of their pre- trained networks. One such network for image classification is available on the link stated herewith&nbsp;<a target=\"_blank\" rel=\"noreferrer noopener\" href=\"https://caffe2.ai/docs/learn-more#null__caffe-neural-network-for-image-classification\">https://caffe2.ai/docs/learn-more#null__caffe-neural-network-for-image-classification</a>&nbsp;and is depicted in the screenshot below.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/caffe2/images/pretrained_model.jpg\" alt=\"Pretrained Model\"/></figure>\n\n\n\n<p>In the screenshot, the image of a dog is classified and labelled with its prediction accuracy. It also says that it took just&nbsp;<strong>0.068 seconds</strong>&nbsp;to classify the image. You may try an image of your own choice by specifying the image URL or uploading the image itself in the options given at the bottom of the screen.</p>\n","protected":false},"excerpt":{"rendered":"<p>Now, as you have got some insights into deep learning, let us get an overview of what is Caffe. Training a CNN Let us learn the process for training a CNN for classifying images. The process consists of the following steps − Data Preparation&nbsp;− In this step, we center-crop the images and resize them so [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[90,156],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3350"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3350"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3350/revisions"}],"predecessor-version":[{"id":4367,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3350/revisions/4367"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3350"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3350"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3350"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3352,"date":"2020-10-01T10:30:36","date_gmt":"2020-10-01T10:30:36","guid":{"rendered":"http://ai.foobrdigital.com/?p=3352"},"modified":"2020-12-25T08:28:13","modified_gmt":"2020-12-25T08:28:13","slug":"caffe2-installation","status":"publish","type":"post","link":"https://python3.foobrdigital.com/caffe2-installation/","title":{"rendered":"Installation"},"content":{"rendered":"\n<p>Now, that you have got enough insights on the capabilities of Caffe2, it is time to experiment Caffe2 on your own. To use the pre-trained models or to develop your models in your own Python code, you must first install Caffe2 on your machine.</p>\n\n\n\n<p>On the installation page of Caffe2 site which is available at the link https://caffe2.ai/docs/getting-started.html you would see the following to select your platform and install type.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/caffe2/images/installation_page.jpg\" alt=\"Installation Page\"/></figure>\n\n\n\n<p>As you can see in the above screenshot,&nbsp;<strong>Caffe2</strong>&nbsp;supports several popular platforms including the mobile ones.</p>\n\n\n\n<p>Now, we shall understand the steps for&nbsp;<strong>MacOS installation</strong>&nbsp;on which all the projects in this tutorial are tested.</p>\n\n\n\n<h2>MacOS Installation</h2>\n\n\n\n<p>The installation can be of four types as given below −</p>\n\n\n\n<ul><li>Pre-Built Binaries</li><li>Build From Source</li><li>Docker Images</li><li>Cloud</li></ul>\n\n\n\n<p>Depending upon your preference, select any of the above as your installation type. The instructions given here are as per the Caffe2 installation site for&nbsp;<strong>pre-built binaries</strong>. It uses Anaconda for&nbsp;<strong>Jupyter environment</strong>. Execute the following command on your console prompt</p>\n\n\n\n<pre class=\"wp-block-code\"><code>pip install torch_nightly -f \nhttps:&#47;&#47;download.pytorch.org/whl/nightly/cpu/torch_nightly.html\n</code></pre>\n\n\n\n<p>In addition to the above, you will need a few third-party libraries, which are installed using the following commands −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>conda install -c anaconda setuptools\nconda install -c conda-forge graphviz  \nconda install -c conda-forge hypothesis\nconda install -c conda-forge ipython\nconda install -c conda-forge jupyter\nconda install -c conda-forge matplotlib\nconda install -c anaconda notebook\nconda install -c anaconda pydot\nconda install -c conda-forge python-nvd3\nconda install -c anaconda pyyaml\nconda install -c anaconda requests\nconda install -c anaconda scikit-image\nconda install -c anaconda scipy\n</code></pre>\n\n\n\n<p>Some of the tutorials in the Caffe2 website also require the installation of&nbsp;<strong>zeromq</strong>, which is installed using the following command −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>conda install -c anaconda zeromq\n</code></pre>\n\n\n\n<h2>Windows/Linux Installation</h2>\n\n\n\n<p>Execute the following command on your console prompt −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>conda install -c pytorch pytorch-nightly-cpu\n</code></pre>\n\n\n\n<p>As you must have noticed, you would need Anaconda to use the above installation. You will need to install the additional packages as specified in the&nbsp;<strong>MacOS installation</strong>.</p>\n\n\n\n<h2>Testing Installation</h2>\n\n\n\n<p>To test your installation, a small Python script is given below, which you can cut and paste in your Juypter project and execute.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from caffe2.python import workspace\nimport numpy as np\nprint (\"Creating random data\")\ndata = np.random.rand(3, 2)\nprint(data)\nprint (\"Adding data to workspace ...\")\nworkspace.FeedBlob(\"mydata\", data)\nprint (\"Retrieving data from workspace\")\nmydata = workspace.FetchBlob(\"mydata\")\nprint(mydata)\n</code></pre>\n\n\n\n<p>When you execute the above code, you should see the following output −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>Creating random data\n&#91;&#91;0.06152718 0.86448082]\n&#91;0.36409966 0.52786113]\n&#91;0.65780886 0.67101053]]\nAdding data to workspace ...\nRetrieving data from workspace\n&#91;&#91;0.06152718 0.86448082]\n&#91;0.36409966 0.52786113]\n&#91;0.65780886 0.67101053]]\n</code></pre>\n\n\n\n<p>The screenshot of the installation test page is shown here for your quick reference −</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/caffe2/images/testing_installation.jpg\" alt=\"Testing Installation\"/></figure>\n\n\n\n<p>Now, that you have installed Caffe2 on your machine, proceed to install the tutorial applications.</p>\n\n\n\n<h2>Tutorial Installation</h2>\n\n\n\n<p>Download the tutorials source using the following command on your console −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>git clone --recursive https://github.com/caffe2/tutorials caffe2_tutorials\n</code></pre>\n\n\n\n<p>After the download is completed, you will find several Python projects in the&nbsp;<strong>caffe2_tutorials</strong>&nbsp;folder in your installation directory. The screenshot of this folder is given for your quick perusal.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>/Users/yourusername/caffe2_tutorials\n</code></pre>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/caffe2/images/tutorial_installation.jpg\" alt=\"Tutorial Installation\"/></figure>\n\n\n\n<p>You can open some of these tutorials to see what the&nbsp;<strong>Caffe2 code</strong>&nbsp;looks like. The next two projects described in this tutorial are largely based on the samples shown above.</p>\n\n\n\n<p>It is now time to do some Python coding of our own. Let us understand, how to use a pre-trained model from Caffe2. Later, you will learn to create your own trivial neural network for training on your own dataset.</p>\n","protected":false},"excerpt":{"rendered":"<p>Now, that you have got enough insights on the capabilities of Caffe2, it is time to experiment Caffe2 on your own. To use the pre-trained models or to develop your models in your own Python code, you must first install Caffe2 on your machine. On the installation page of Caffe2 site which is available at [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[90,156],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3352"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3352"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3352/revisions"}],"predecessor-version":[{"id":4366,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3352/revisions/4366"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3352"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3352"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3352"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3354,"date":"2020-10-01T10:31:41","date_gmt":"2020-10-01T10:31:41","guid":{"rendered":"http://ai.foobrdigital.com/?p=3354"},"modified":"2020-12-25T08:28:13","modified_gmt":"2020-12-25T08:28:13","slug":"caffe2-verifying-access-to-pre-trained-models","status":"publish","type":"post","link":"https://python3.foobrdigital.com/caffe2-verifying-access-to-pre-trained-models/","title":{"rendered":"Verifying Access to Pre-Trained Models"},"content":{"rendered":"\n<p>Before you learn to use a pre-trained model in your Python application, let us first verify that the models are installed on your machine and are accessible through the Python code.</p>\n\n\n\n<p>When you install Caffe2, the pre-trained models are copied in the installation folder. On the machine with Anaconda installation, these models are available in the following folder.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>anaconda3/lib/python3.7/site-packages/caffe2/python/models\n</code></pre>\n\n\n\n<p>Check out the installation folder on your machine for the presence of these models. You can try loading these models from the installation folder with the following short Python script −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>CAFFE_MODELS = os.path.expanduser(\"/anaconda3/lib/python3.7/site-packages/caffe2/python/models\")\nINIT_NET = os.path.join(CAFFE_MODELS, 'squeezenet', 'init_net.pb')\nPREDICT_NET = os.path.join(CAFFE_MODELS, 'squeezenet', 'predict_net.pb')\nprint(INIT_NET)\nprint(PREDICT_NET)\n</code></pre>\n\n\n\n<p>When the script runs successfully, you will see the following output −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>/anaconda3/lib/python3.7/site-packages/caffe2/python/models/squeezenet/init_net.pb\n/anaconda3/lib/python3.7/site-packages/caffe2/python/models/squeezenet/predict_net.pb\n</code></pre>\n\n\n\n<p>This confirms that the&nbsp;<strong>squeezenet</strong>&nbsp;module is installed on your machine and is accessible to your code.</p>\n\n\n\n<p>Now, you are ready to write your own Python code for image classification using Caffe2&nbsp;<strong>squeezenet</strong>&nbsp;pre-trained module.</p>\n","protected":false},"excerpt":{"rendered":"<p>Before you learn to use a pre-trained model in your Python application, let us first verify that the models are installed on your machine and are accessible through the Python code. When you install Caffe2, the pre-trained models are copied in the installation folder. On the machine with Anaconda installation, these models are available in [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[90,156],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3354"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3354"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3354/revisions"}],"predecessor-version":[{"id":4365,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3354/revisions/4365"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3354"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3354"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3354"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3356,"date":"2020-10-01T10:39:23","date_gmt":"2020-10-01T10:39:23","guid":{"rendered":"http://ai.foobrdigital.com/?p=3356"},"modified":"2020-12-25T08:28:13","modified_gmt":"2020-12-25T08:28:13","slug":"image-classification-using-pre-trained-model","status":"publish","type":"post","link":"https://python3.foobrdigital.com/image-classification-using-pre-trained-model/","title":{"rendered":"Image Classification Using Pre-Trained Model"},"content":{"rendered":"\n<p>In this lesson, you will learn to use a pre-trained model to detect objects in a given image. You will use&nbsp;<strong>squeezenet</strong>&nbsp;pre-trained module that detects and classifies the objects in a given image with a great accuracy.</p>\n\n\n\n<p>Open a new&nbsp;<strong>Juypter notebook</strong>&nbsp;and follow the steps to develop this image classification application.</p>\n\n\n\n<h2>Importing Libraries</h2>\n\n\n\n<p>First, we import the required packages using the below code −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from caffe2.proto import caffe2_pb2\nfrom caffe2.python import core, workspace, models\nimport numpy as np\nimport skimage.io\nimport skimage.transform\nfrom matplotlib import pyplot\nimport os\nimport urllib.request as urllib2\nimport operator\n</code></pre>\n\n\n\n<p>Next, we set up a few&nbsp;<strong>variables</strong>&nbsp;−</p>\n\n\n\n<pre class=\"wp-block-code\"><code>INPUT_IMAGE_SIZE = 227\nmean = 128\n</code></pre>\n\n\n\n<p>The images used for training will obviously be of varied sizes. All these images must be converted into a fixed size for accurate training. Likewise, the test images and the image which you want to predict in the production environment must also be converted to the size, the same as the one used during training. Thus, we create a variable above called&nbsp;<strong>INPUT_IMAGE_SIZE</strong>&nbsp;having value&nbsp;<strong>227</strong>. Hence, we will convert all our images to the size&nbsp;<strong>227&#215;227</strong>&nbsp;before using it in our classifier.</p>\n\n\n\n<p>We also declare a variable called&nbsp;<strong>mean</strong>&nbsp;having value&nbsp;<strong>128</strong>, which is used later for improving the classification results.</p>\n\n\n\n<p>Next, we will develop two functions for processing the image.</p>\n\n\n\n<h2>Image Processing</h2>\n\n\n\n<p>The image processing consists of two steps. First one is to resize the image, and the second one is to centrally crop the image. For these two steps, we will write two functions for resizing and cropping.</p>\n\n\n\n<h3>Image Resizing</h3>\n\n\n\n<p>First, we will write a function for resizing the image. As said earlier, we will resize the image to&nbsp;<strong>227&#215;227</strong>. So let us define the function&nbsp;<strong>resize</strong>&nbsp;as follows −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>def resize(img, input_height, input_width):\n</code></pre>\n\n\n\n<p>We obtain the aspect ratio of the image by dividing the width by the height.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>original_aspect = img.shape&#91;1]/float(img.shape&#91;0])\n</code></pre>\n\n\n\n<p>If the aspect ratio is greater than 1, it indicates that the image is wide, that to say it is in the landscape mode. We now adjust the image height and return the resized image using the following code −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>if(original_aspect>1):\n   new_height = int(original_aspect * input_height)\n   return skimage.transform.resize(img, (input_width,\n   new_height), mode='constant', anti_aliasing=True, anti_aliasing_sigma=None)\n</code></pre>\n\n\n\n<p>If the aspect ratio is&nbsp;<strong>less than 1</strong>, it indicates the&nbsp;<strong>portrait mode</strong>. We now adjust the width using the following code −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>if(original_aspect&lt;1):\n   new_width = int(input_width/original_aspect)\n   return skimage.transform.resize(img, (new_width,\n   input_height), mode='constant', anti_aliasing=True, anti_aliasing_sigma=None)\n</code></pre>\n\n\n\n<p>If the aspect ratio equals&nbsp;<strong>1</strong>, we do not make any height/width adjustments.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>if(original_aspect == 1):\n   return skimage.transform.resize(img, (input_width,\n   input_height), mode='constant', anti_aliasing=True, anti_aliasing_sigma=None)\n</code></pre>\n\n\n\n<p>The full function code is given below for your quick reference −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>def resize(img, input_height, input_width):\n   original_aspect = img.shape&#91;1]/float(img.shape&#91;0])\n   if(original_aspect>1):\n      new_height = int(original_aspect * input_height)\n      return skimage.transform.resize(img, (input_width,\n\t   new_height), mode='constant', anti_aliasing=True, anti_aliasing_sigma=None)\n   if(original_aspect&lt;1):\n         new_width = int(input_width/original_aspect)\n         return skimage.transform.resize(img, (new_width,\n         input_height), mode='constant', anti_aliasing=True, anti_aliasing_sigma=None)\n   if(original_aspect == 1):\n         return skimage.transform.resize(img, (input_width,\n         input_height), mode='constant', anti_aliasing=True, anti_aliasing_sigma=None)\n</code></pre>\n\n\n\n<p>We will now write a function for cropping the image around its center.</p>\n\n\n\n<h3>Image Cropping</h3>\n\n\n\n<p>We declare the&nbsp;<strong>crop_image</strong>&nbsp;function as follows −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>def crop_image(img,cropx,cropy):\n</code></pre>\n\n\n\n<p>We extract the dimensions of the image using the following statement −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>y,x,c = img.shape\n</code></pre>\n\n\n\n<p>We create a new starting point for the image using the following two lines of code −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>startx = x//2-(cropx//2)\nstarty = y//2-(cropy//2)\n</code></pre>\n\n\n\n<p>Finally, we return the cropped image by creating an image object with the new dimensions −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>return img&#91;starty:starty+cropy,startx:startx+cropx]\n</code></pre>\n\n\n\n<p>The entire function code is given below for your quick reference −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>def crop_image(img,cropx,cropy):\n   y,x,c = img.shape\n   startx = x//2-(cropx//2)\n   starty = y//2-(cropy//2)\n   return img&#91;starty:starty+cropy,startx:startx+cropx]\n</code></pre>\n\n\n\n<p>Now, we will write code to test these functions.</p>\n\n\n\n<h2>Processing Image</h2>\n\n\n\n<p>Firstly, copy an image file into&nbsp;<strong>images</strong>&nbsp;subfolder within your project directory.&nbsp;<strong>tree.jpg</strong>&nbsp;file is copied in the project. The following Python code loads the image and displays it on the console −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>img = skimage.img_as_float(skimage.io.imread(\"images/tree.jpg\")).astype(np.float32)\nprint(\"Original Image Shape: \" , img.shape)\npyplot.figure()\npyplot.imshow(img)\npyplot.title('Original image')\n</code></pre>\n\n\n\n<p>The output is as follows −</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/caffe2/images/processing_image.jpg\" alt=\"Processing Image\"/></figure>\n\n\n\n<p>Note that size of the original image is <strong>600 x 960</strong>. We need to resize this to our specification of <strong>227 x 227</strong>. Calling our earlier-defined <strong>resize</strong>function does this job.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>img = resize(img, INPUT_IMAGE_SIZE, INPUT_IMAGE_SIZE)\nprint(\"Image Shape after resizing: \" , img.shape)\npyplot.figure()\npyplot.imshow(img)\npyplot.title('Resized image')</code></pre>\n\n\n\n<p>The output is as given below −</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/caffe2/images/original_image.jpg\" alt=\"Original Image\"/></figure>\n\n\n\n<p>Note that now the image size is&nbsp;<strong>227 x 363</strong>. We need to crop this to&nbsp;<strong>227 x 227</strong>&nbsp;for the final feed to our algorithm. We call the previously-defined crop function for this purpose.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>img = crop_image(img, INPUT_IMAGE_SIZE, INPUT_IMAGE_SIZE)\nprint(\"Image Shape after cropping: \" , img.shape)\npyplot.figure()\npyplot.imshow(img)\npyplot.title('Center Cropped')\n</code></pre>\n\n\n\n<p>Below mentioned is the output of the code −</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/caffe2/images/cropping_image.jpg\" alt=\"Cropping Image\"/></figure>\n\n\n\n<p>At this point, the image is of size&nbsp;<strong>227 x 227</strong>&nbsp;and is ready for further processing. We now swap the image axes to extract the three colours into three different zones.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>img = img.swapaxes(1, 2).swapaxes(0, 1)\nprint(\"CHW Image Shape: \" , img.shape)\n</code></pre>\n\n\n\n<p>Given below is the output −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>CHW Image Shape: (3, 227, 227)\n</code></pre>\n\n\n\n<p>Note that the last axis has now become the first dimension in the array. We will now plot the three channels using the following code −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>pyplot.figure()\nfor i in range(3):\n   pyplot.subplot(1, 3, i+1)\n   pyplot.imshow(img&#91;i])\n   pyplot.axis('off')\n   pyplot.title('RGB channel %d' % (i+1))\n</code></pre>\n\n\n\n<p>The output is stated below −</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/caffe2/images/dimension.jpg\" alt=\"Dimension\"/></figure>\n\n\n\n<p>Finally, we do some additional processing on the image such as converting&nbsp;<strong>Red Green Blue</strong>&nbsp;to&nbsp;<strong>Blue Green Red (RGB to BGR)</strong>, removing mean for better results and adding batch size axis using the following three lines of code −</p>\n\n\n\n<pre class=\"wp-block-code\"><code># convert RGB --> BGR\nimg = img&#91;(2, 1, 0), :, :]\n# remove mean\nimg = img * 255 - mean\n# add batch size axis\nimg = img&#91;np.newaxis, :, :, :].astype(np.float32)\n</code></pre>\n\n\n\n<p>At this point, your image is in&nbsp;<strong>NCHW format</strong>&nbsp;and is ready for feeding into our network. Next, we will load our pre-trained model files and feed the above image into it for prediction.</p>\n\n\n\n<h2>Predicting Objects in Processed Image</h2>\n\n\n\n<p>We first setup the paths for the&nbsp;<strong>init</strong>&nbsp;and&nbsp;<strong>predict</strong>&nbsp;networks defined in the pre-trained models of Caffe.</p>\n\n\n\n<h3>Setting Model File Paths</h3>\n\n\n\n<p>Remember from our earlier discussion, all the pre-trained models are installed in the&nbsp;<strong>models</strong>&nbsp;folder. We set up the path to this folder as follows −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>CAFFE_MODELS = os.path.expanduser(\"/anaconda3/lib/python3.7/site-packages/caffe2/python/models\")\n</code></pre>\n\n\n\n<p>We set up the path to the&nbsp;<strong>init_net</strong>&nbsp;protobuf file of the&nbsp;<strong>squeezenet</strong>&nbsp;model as follows −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>INIT_NET = os.path.join(CAFFE_MODELS, 'squeezenet', 'init_net.pb')\n</code></pre>\n\n\n\n<p>Likewise, we set up the path to the&nbsp;<strong>predict_net</strong>&nbsp;protobuf as follows −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>PREDICT_NET = os.path.join(CAFFE_MODELS, 'squeezenet', 'predict_net.pb')\n</code></pre>\n\n\n\n<p>We print the two paths for diagnosis purpose −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>print(INIT_NET)\nprint(PREDICT_NET)\n</code></pre>\n\n\n\n<p>The above code along with the output is given here for your quick reference −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>CAFFE_MODELS = os.path.expanduser(\"/anaconda3/lib/python3.7/site-packages/caffe2/python/models\")\nINIT_NET = os.path.join(CAFFE_MODELS, 'squeezenet', 'init_net.pb')\nPREDICT_NET = os.path.join(CAFFE_MODELS, 'squeezenet', 'predict_net.pb')\nprint(INIT_NET)\nprint(PREDICT_NET)\n</code></pre>\n\n\n\n<p>The output is mentioned below −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>/anaconda3/lib/python3.7/site-packages/caffe2/python/models/squeezenet/init_net.pb\n/anaconda3/lib/python3.7/site-packages/caffe2/python/models/squeezenet/predict_net.pb\n</code></pre>\n\n\n\n<p>Next, we will create a predictor.</p>\n\n\n\n<h3>Creating Predictor</h3>\n\n\n\n<p>We read the model files using the following two statements −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>with open(INIT_NET, \"rb\") as f:\n   init_net = f.read()\nwith open(PREDICT_NET, \"rb\") as f:\n   predict_net = f.read()\n</code></pre>\n\n\n\n<p>The predictor is created by passing pointers to the two files as parameters to the&nbsp;<strong>Predictor</strong>&nbsp;function.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>p = workspace.Predictor(init_net, predict_net)\n</code></pre>\n\n\n\n<p>The&nbsp;<strong>p</strong>&nbsp;object is the predictor, which is used for predicting the objects in any given image. Note that each input image must be in NCHW format as what we have done earlier to our&nbsp;<strong>tree.jpg</strong>&nbsp;file.</p>\n\n\n\n<h3>Predicting Objects</h3>\n\n\n\n<p>To predict the objects in a given image is trivial &#8211; just executing a single line of command. We call&nbsp;<strong>run</strong>&nbsp;method on the&nbsp;<strong>predictor</strong>&nbsp;object for an object detection in a given image.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>results = p.run({'data': img})\n</code></pre>\n\n\n\n<p>The prediction results are now available in the&nbsp;<strong>results</strong>&nbsp;object, which we convert to an array for our readability.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>results = np.asarray(results)\n</code></pre>\n\n\n\n<p>Print the dimensions of the array for your understanding using the following statement −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>print(\"results shape: \", results.shape)\n</code></pre>\n\n\n\n<p>The output is as shown below −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>results shape: (1, 1, 1000, 1, 1)\n</code></pre>\n\n\n\n<p>We will now remove the unnecessary axis −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>preds = np.squeeze(results)\n</code></pre>\n\n\n\n<p>The topmost predication can now be retrieved by taking the&nbsp;<strong>max</strong>&nbsp;value in the&nbsp;<strong>preds</strong>&nbsp;array.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>curr_pred, curr_conf = max(enumerate(preds), key=operator.itemgetter(1))\nprint(\"Prediction: \", curr_pred)\nprint(\"Confidence: \", curr_conf)\n</code></pre>\n\n\n\n<p>The output is as follows −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>Prediction: 984\nConfidence: 0.89235985\n</code></pre>\n\n\n\n<p>As you see the model has predicted an object with an index value&nbsp;<strong>984</strong>&nbsp;with&nbsp;<strong>89%</strong>&nbsp;confidence. The index of 984 does not make much sense to us in understanding what kind of object is detected. We need to get the stringified name for the object using its index value. The kind of objects that the model recognizes along with their corresponding index values are available on a github repository.</p>\n\n\n\n<p>Now, we will see how to retrieve the name for our object having index value of 984.</p>\n\n\n\n<h2>Stringifying Result</h2>\n\n\n\n<p>We create a URL object to the github repository as follows −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>codes = \"https://gist.githubusercontent.com/aaronmarkham/cd3a6b6ac0\n71eca6f7b4a6e40e6038aa/raw/9edb4038a37da6b5a44c3b5bc52e448ff09bfe5b/alexnet_codes\"\n</code></pre>\n\n\n\n<p>We read the contents of the URL −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>response = urllib2.urlopen(codes)\n</code></pre>\n\n\n\n<p>The response will contain a list of all codes and its descriptions. Few lines of the response are shown below for your understanding of what it contains −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>5: 'electric ray, crampfish, numbfish, torpedo',\n6: 'stingray',\n7: 'cock',\n8: 'hen',\n9: 'ostrich, Struthio camelus',\n10: 'brambling, Fringilla montifringilla',\n</code></pre>\n\n\n\n<p>We now iterate the entire array to locate our desired code of 984 using a&nbsp;<strong>for</strong>&nbsp;loop as follows −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>for line in response:\n   mystring = line.decode('ascii')\n   code, result = mystring.partition(\":\")&#91;::2]\n   code = code.strip()\n   result = result.replace(\"'\", \"\")\n   if (code == str(curr_pred)):\n      name = result.split(\",\")&#91;0]&#91;1:]\n      print(\"Model predicts\", name, \"with\", curr_conf, \"confidence\")\n</code></pre>\n\n\n\n<p>When you run the code, you will see the following output −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>Model predicts rapeseed with 0.89235985 confidence\n</code></pre>\n\n\n\n<p>You may now try the model on another image.</p>\n\n\n\n<h2>Predicting a Different Image</h2>\n\n\n\n<p>To predict another image, simply copy the image file into the&nbsp;<strong>images</strong>&nbsp;folder of your project directory. This is the directory in which our earlier&nbsp;<strong>tree.jpg</strong>&nbsp;file is stored. Change the name of the image file in the code. Only one change is required as shown below</p>\n\n\n\n<pre class=\"wp-block-code\"><code>img = skimage.img_as_float(skimage.io.imread(\"images/pretzel.jpg\")).astype(np.float32)\n</code></pre>\n\n\n\n<p>The original picture and the prediction result are shown below −</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/caffe2/images/predicting_image.jpg\" alt=\"Predicting Image\"/></figure>\n\n\n\n<p>The output is mentioned below −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>Model predicts pretzel with 0.99999976 confidence\n</code></pre>\n\n\n\n<p>As you see the pre-trained model is able to detect objects in a given image with a great amount of accuracy.</p>\n\n\n\n<h2>Full Source</h2>\n\n\n\n<p>The full source for the above code that uses a pre-trained model for object detection in a given image is mentioned here for your quick reference −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>def crop_image(img,cropx,cropy):\n   y,x,c = img.shape\n   startx = x//2-(cropx//2)\n   starty = y//2-(cropy//2)\n   return img&#91;starty:starty+cropy,startx:startx+cropx]\nimg = skimage.img_as_float(skimage.io.imread(\"images/pretzel.jpg\")).astype(np.float32)\nprint(\"Original Image Shape: \" , img.shape)\npyplot.figure()\npyplot.imshow(img)\npyplot.title('Original image')\nimg = resize(img, INPUT_IMAGE_SIZE, INPUT_IMAGE_SIZE)\nprint(\"Image Shape after resizing: \" , img.shape)\npyplot.figure()\npyplot.imshow(img)\npyplot.title('Resized image')\nimg = crop_image(img, INPUT_IMAGE_SIZE, INPUT_IMAGE_SIZE)\nprint(\"Image Shape after cropping: \" , img.shape)\npyplot.figure()\npyplot.imshow(img)\npyplot.title('Center Cropped')\nimg = img.swapaxes(1, 2).swapaxes(0, 1)\nprint(\"CHW Image Shape: \" , img.shape)\npyplot.figure()\nfor i in range(3):\npyplot.subplot(1, 3, i+1)\npyplot.imshow(img&#91;i])\npyplot.axis('off')\npyplot.title('RGB channel %d' % (i+1))\n# convert RGB --> BGR\nimg = img&#91;(2, 1, 0), :, :]\n# remove mean\nimg = img * 255 - mean\n# add batch size axis\nimg = img&#91;np.newaxis, :, :, :].astype(np.float32)\nCAFFE_MODELS = os.path.expanduser(\"/anaconda3/lib/python3.7/site-packages/caffe2/python/models\")\nINIT_NET = os.path.join(CAFFE_MODELS, 'squeezenet', 'init_net.pb')\nPREDICT_NET = os.path.join(CAFFE_MODELS, 'squeezenet', 'predict_net.pb')\nprint(INIT_NET)\nprint(PREDICT_NET)\nwith open(INIT_NET, \"rb\") as f:\n   init_net = f.read()\nwith open(PREDICT_NET, \"rb\") as f:\n   predict_net = f.read()\np = workspace.Predictor(init_net, predict_net)\nresults = p.run({'data': img})\nresults = np.asarray(results)\nprint(\"results shape: \", results.shape)\npreds = np.squeeze(results)\ncurr_pred, curr_conf = max(enumerate(preds), key=operator.itemgetter(1))\nprint(\"Prediction: \", curr_pred)\nprint(\"Confidence: \", curr_conf)\ncodes = \"https://gist.githubusercontent.com/aaronmarkham/cd3a6b6ac071eca6f7b4a6e40e6038aa/raw/9edb4038a37da6b5a44c3b5bc52e448ff09bfe5b/alexnet_codes\"\nresponse = urllib2.urlopen(codes)\nfor line in response:\n   mystring = line.decode('ascii')\n   code, result = mystring.partition(\":\")&#91;::2]\n   code = code.strip()\n   result = result.replace(\"'\", \"\")\n   if (code == str(curr_pred)):\n      name = result.split(\",\")&#91;0]&#91;1:]\n      print(\"Model predicts\", name, \"with\", curr_conf, \"confidence\")\n</code></pre>\n\n\n\n<p>By this time, you know how to use a pre-trained model for doing the predictions on your dataset.</p>\n\n\n\n<p>What’s next is to learn how to define your&nbsp;<strong>neural network (NN)</strong>&nbsp;architectures in&nbsp;<strong>Caffe2</strong>&nbsp;and train them on your dataset. We will now learn how to create a trivial single layer NN.</p>\n","protected":false},"excerpt":{"rendered":"<p>In this lesson, you will learn to use a pre-trained model to detect objects in a given image. You will use&nbsp;squeezenet&nbsp;pre-trained module that detects and classifies the objects in a given image with a great accuracy. Open a new&nbsp;Juypter notebook&nbsp;and follow the steps to develop this image classification application. Importing Libraries First, we import the [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[90,156],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3356"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3356"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3356/revisions"}],"predecessor-version":[{"id":4364,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3356/revisions/4364"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3356"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3356"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3356"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3359,"date":"2020-10-01T10:44:31","date_gmt":"2020-10-01T10:44:31","guid":{"rendered":"http://ai.foobrdigital.com/?p=3359"},"modified":"2020-12-25T08:28:13","modified_gmt":"2020-12-25T08:28:13","slug":"caffe2-creating-your-own-network","status":"publish","type":"post","link":"https://python3.foobrdigital.com/caffe2-creating-your-own-network/","title":{"rendered":"Creating Your Own Network"},"content":{"rendered":"\n<p>In this lesson, you will learn to define a&nbsp;<strong>single layer neural network (NN)</strong>&nbsp;in Caffe2 and run it on a randomly generated dataset. We will write code to graphically depict the network architecture, print input, output, weights, and bias values. To understand this lesson, you must be familiar with&nbsp;<strong>neural network architectures</strong>, its&nbsp;<strong>terms</strong>&nbsp;and&nbsp;<strong>mathematics</strong>&nbsp;used in them.</p>\n\n\n\n<h2>Network Architecture</h2>\n\n\n\n<p>Let us consider that we want to build a single layer NN as shown in the figure below −</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/caffe2/images/network_architecture.jpg\" alt=\"Network Architecture\"/></figure>\n\n\n\n<p>Mathematically, this network is represented by the following Python code −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>Y = X * W^T + b\n</code></pre>\n\n\n\n<p>Where&nbsp;<strong>X, W, b</strong>&nbsp;are tensors and&nbsp;<strong>Y</strong>&nbsp;is the output. We will fill all three tensors with some random data, run the network and examine the&nbsp;<strong>Y</strong>&nbsp;output. To define the network and tensors, Caffe2 provides several&nbsp;<strong>Operator</strong>&nbsp;functions.</p>\n\n\n\n<h2>Caffe2 Operators</h2>\n\n\n\n<p>In Caffe2,&nbsp;<strong>Operator</strong>&nbsp;is the basic unit of computation. The Caffe2&nbsp;<strong>Operator</strong>&nbsp;is represented as follows.</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/caffe2/images/caffe_operators.jpg\" alt=\"Caffe2 Operators\"/></figure>\n\n\n\n<p>Caffe2 provides an exhaustive list of operators. For the network that we are designing currently, we will use the operator called FC, which computes the result of passing an input vector&nbsp;<strong>X</strong>&nbsp;into a fully connected network with a two-dimensional weight matrix&nbsp;<strong>W</strong>&nbsp;and a single-dimensional bias vector&nbsp;<strong>b</strong>. In other words, it computes the following mathematical equation</p>\n\n\n\n<pre class=\"wp-block-code\"><code>Y = X * W^T + b\n</code></pre>\n\n\n\n<p>Where&nbsp;<strong>X</strong>&nbsp;has dimensions&nbsp;<strong>(M x k), W</strong>&nbsp;has dimensions&nbsp;<strong>(n x k)</strong>&nbsp;and&nbsp;<strong>b</strong>&nbsp;is&nbsp;<strong>(1 x n)</strong>. The output&nbsp;<strong>Y</strong>&nbsp;will be of dimension&nbsp;<strong>(M x n)</strong>, where&nbsp;<strong>M</strong>&nbsp;is the batch size.</p>\n\n\n\n<p>For the vectors&nbsp;<strong>X</strong>&nbsp;and&nbsp;<strong>W</strong>, we will use the&nbsp;<strong>GaussianFill</strong>&nbsp;operator to create some random data. For generating bias values&nbsp;<strong>b</strong>, we will use&nbsp;<strong>ConstantFill</strong>&nbsp;operator.</p>\n\n\n\n<p>We will now proceed to define our network.</p>\n\n\n\n<h2>Creating Network</h2>\n\n\n\n<p>First of all, import the required packages −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from caffe2.python import core, workspace\n</code></pre>\n\n\n\n<p>Next, define the network by calling&nbsp;<strong>core.Net</strong>&nbsp;as follows −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>net = core.Net(\"SingleLayerFC\")\n</code></pre>\n\n\n\n<p>The name of the network is specified as&nbsp;<strong>SingleLayerFC</strong>. At this point, the network object called net is created. It does not contain any layers so far.</p>\n\n\n\n<h2>Creating Tensors</h2>\n\n\n\n<p>We will now create the three vectors required by our network. First, we will create X tensor by calling&nbsp;<strong>GaussianFill</strong>&nbsp;operator as follows −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>X = net.GaussianFill(&#91;], &#91;\"X\"], mean=0.0, std=1.0, shape=&#91;2, 3], run_once=0)\n</code></pre>\n\n\n\n<p>The&nbsp;<strong>X</strong>&nbsp;vector has dimensions&nbsp;<strong>2 x 3</strong>&nbsp;with the mean data value of 0,0 and standard deviation of&nbsp;<strong>1.0</strong>.</p>\n\n\n\n<p>Likewise, we create&nbsp;<strong>W</strong>&nbsp;tensor as follows −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>W = net.GaussianFill(&#91;], &#91;\"W\"], mean=0.0, std=1.0, shape=&#91;5, 3], run_once=0)\n</code></pre>\n\n\n\n<p>The&nbsp;<strong>W</strong>&nbsp;vector is of size&nbsp;<strong>5 x 3</strong>.</p>\n\n\n\n<p>Finally, we create bias&nbsp;<strong>b</strong>&nbsp;matrix of size 5.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>b = net.ConstantFill(&#91;], &#91;\"b\"], shape=&#91;5,], value=1.0, run_once=0)\n</code></pre>\n\n\n\n<p>Now, comes the most important part of the code and that is defining the network itself.</p>\n\n\n\n<h3>Defining Network</h3>\n\n\n\n<p>We define the network in the following Python statement −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>Y = X.FC(&#91;W, b], &#91;\"Y\"])\n</code></pre>\n\n\n\n<p>We call&nbsp;<strong>FC</strong>&nbsp;operator on the input data&nbsp;<strong>X</strong>. The weights are specified in&nbsp;<strong>W</strong>&nbsp;and bias in b. The output is&nbsp;<strong>Y</strong>. Alternatively, you may create the network using the following Python statement, which is more verbose.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>Y = net.FC(&#91;X, W, b], &#91;\"Y\"])\n</code></pre>\n\n\n\n<p>At this point, the network is simply created. Until we run the network at least once, it will not contain any data. Before running the network, we will examine its architecture.</p>\n\n\n\n<h2>Printing Network Architecture</h2>\n\n\n\n<p>Caffe2 defines the network architecture in a JSON file, which can be examined by calling the Proto method on the created&nbsp;<strong>net</strong>&nbsp;object.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>print (net.Proto())\n</code></pre>\n\n\n\n<p>This produces the following output −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>name: \"SingleLayerFC\"\nop {\n   output: \"X\"\n   name: \"\"\n   type: \"GaussianFill\"\n   arg {\n      name: \"mean\"\n      f: 0.0\n   }\n   arg {\n      name: \"std\"\n      f: 1.0\n   }\n   arg {\n      name: \"shape\"\n      ints: 2\n      ints: 3\n   }\n   arg {\n      name: \"run_once\"\n      i: 0\n   }\n}\nop {\n   output: \"W\"\n   name: \"\"\n   type: \"GaussianFill\"\n   arg {\n      name: \"mean\"\n      f: 0.0\n   }\n   arg {\n      name: \"std\"\n      f: 1.0\n   }\n   arg {\n      name: \"shape\"\n      ints: 5\n      ints: 3\n   }\n   arg {\n      name: \"run_once\"\n      i: 0\n   }\n}\nop {\n   output: \"b\"\n   name: \"\"\n   type: \"ConstantFill\"\n   arg {\n      name: \"shape\"\n      ints: 5\n   }\n   arg {\n      name: \"value\"\n      f: 1.0\n   }\n   arg {\n      name: \"run_once\"\n      i: 0\n   }\n}\nop {\n   input: \"X\"\n   input: \"W\"\n   input: \"b\"\n   output: \"Y\"\n   name: \"\"\n   type: \"FC\"\n}\n</code></pre>\n\n\n\n<p>As you can see in the above listing, it first defines the operators&nbsp;<strong>X, W</strong>&nbsp;and&nbsp;<strong>b</strong>. Let us examine the definition of&nbsp;<strong>W</strong>&nbsp;as an example. The type of&nbsp;<strong>W</strong>&nbsp;is specified as&nbsp;<strong>GausianFill</strong>. The&nbsp;<strong>mean</strong>&nbsp;is defined as float&nbsp;<strong>0.0</strong>, the standard deviation is defined as float&nbsp;<strong>1.0</strong>, and the&nbsp;<strong>shape</strong>&nbsp;is&nbsp;<strong>5 x 3</strong>.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>op {\n   output: \"W\"\n   name: \"\" type: \"GaussianFill\"\n   arg {\n      name: \"mean\" \n\t   f: 0.0\n   }\n   arg { \n      name: \"std\" \n      f: 1.0\n   }\n   arg { \n      name: \"shape\" \n      ints: 5 \n      ints: 3\n   }\n   ...\n}\n</code></pre>\n\n\n\n<p>Examine the definitions of&nbsp;<strong>X</strong>&nbsp;and&nbsp;<strong>b</strong>&nbsp;for your own understanding. Finally, let us look at the definition of our single layer network, which is reproduced here</p>\n\n\n\n<pre class=\"wp-block-code\"><code>op {\n   input: \"X\"\n   input: \"W\"\n   input: \"b\"\n   output: \"Y\"\n   name: \"\"\n   type: \"FC\"\n}\n</code></pre>\n\n\n\n<p>Here, the network type is&nbsp;<strong>FC</strong>&nbsp;(Fully Connected) with&nbsp;<strong>X, W, b</strong>&nbsp;as inputs and&nbsp;<strong>Y</strong>&nbsp;is the output. This network definition is too verbose and for large networks, it will become tedious to examine its contents. Fortunately, Caffe2 provides a graphical representation for the created networks.</p>\n\n\n\n<h2>Network Graphical Representation</h2>\n\n\n\n<p>To get the graphical representation of the network, run the following code snippet, which is essentially only two lines of Python code.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from caffe2.python import net_drawer\nfrom IPython import display\ngraph = net_drawer.GetPydotGraph(net, rankdir=\"LR\")\ndisplay.Image(graph.create_png(), width=800)\n</code></pre>\n\n\n\n<p>When you run the code, you will see the following output −</p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://www.tutorialspoint.com/caffe2/images/graphical_representation.jpg\" alt=\"Graphical Representation\"/></figure>\n\n\n\n<p>For large networks, the graphical representation becomes extremely useful in visualizing and debugging network definition errors.</p>\n\n\n\n<p>Finally, it is now time to run the network.</p>\n\n\n\n<h2>Running Network</h2>\n\n\n\n<p>You run the network by calling the&nbsp;<strong>RunNetOnce</strong>&nbsp;method on the&nbsp;<strong>workspace</strong>&nbsp;object −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>workspace.RunNetOnce(net)\n</code></pre>\n\n\n\n<p>After the network is run once, all our data that is generated at random would be created, fed into the network and the output will be created. The tensors which are created after running the network are called&nbsp;<strong>blobs</strong>&nbsp;in Caffe2. The workspace consists of the&nbsp;<strong>blobs</strong>&nbsp;you create and store in memory. This is quite similar to Matlab.</p>\n\n\n\n<p>After running the network, you can examine the&nbsp;<strong>blobs</strong>&nbsp;that the workspace contains using the following&nbsp;<strong>print</strong>&nbsp;command</p>\n\n\n\n<pre class=\"wp-block-code\"><code>print(\"Blobs in the workspace: {}\".format(workspace.Blobs()))\n</code></pre>\n\n\n\n<p>You will see the following output −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>Blobs in the workspace: &#91;'W', 'X', 'Y', 'b']\n</code></pre>\n\n\n\n<p>Note that the workspace consists of three input blobs −&nbsp;<strong>X, W</strong>&nbsp;and&nbsp;<strong>b</strong>. It also contains the output blob called&nbsp;<strong>Y</strong>. Let us now examine the contents of these blobs.</p>\n\n\n\n<pre class=\"wp-block-code\"><code>for name in workspace.Blobs():\n   print(\"{}:\\n{}\".format(name, workspace.FetchBlob(name)))\n</code></pre>\n\n\n\n<p>You will see the following output −</p>\n\n\n\n<pre class=\"wp-block-code\"><code>W:\n&#91;&#91; 1.0426593 0.15479846 0.25635982]\n&#91;-2.2461145 1.4581774 0.16827184]\n&#91;-0.12009818 0.30771437 0.00791338]\n&#91; 1.2274994 -0.903331 -0.68799865]\n&#91; 0.30834186 -0.53060573 0.88776857]]\nX:\n&#91;&#91; 1.6588869e+00 1.5279824e+00 1.1889904e+00]\n&#91; 6.7048723e-01 -9.7490678e-04 2.5114202e-01]]\nY:\n&#91;&#91; 3.2709925 -0.297907 1.2803618 0.837985 1.7562964]\n&#91; 1.7633215 -0.4651525 0.9211631 1.6511179 1.4302125]]\nb:\n&#91;1. 1. 1. 1. 1.]\n</code></pre>\n\n\n\n<p>Note that the data on your machine or as a matter of fact on every run of the network would be different as all inputs are created at random. You have now successfully defined a network and run it on your computer.</p>\n","protected":false},"excerpt":{"rendered":"<p>In this lesson, you will learn to define a&nbsp;single layer neural network (NN)&nbsp;in Caffe2 and run it on a randomly generated dataset. We will write code to graphically depict the network architecture, print input, output, weights, and bias values. To understand this lesson, you must be familiar with&nbsp;neural network architectures, its&nbsp;terms&nbsp;and&nbsp;mathematics&nbsp;used in them. Network Architecture [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[90,156],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3359"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3359"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3359/revisions"}],"predecessor-version":[{"id":4363,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3359/revisions/4363"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3359"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3359"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3359"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}},{"id":3361,"date":"2020-10-01T10:45:22","date_gmt":"2020-10-01T10:45:22","guid":{"rendered":"http://ai.foobrdigital.com/?p=3361"},"modified":"2020-12-25T08:28:13","modified_gmt":"2020-12-25T08:28:13","slug":"caffe2-defining-complex-networks","status":"publish","type":"post","link":"https://python3.foobrdigital.com/caffe2-defining-complex-networks/","title":{"rendered":"Defining Complex Networks"},"content":{"rendered":"\n<p>In the previous lesson, you learned to create a trivial network and learned how to execute it and examine its output. The process for creating complex networks is similar to the process described above. Caffe2 provides a huge set of operators for creating complex architectures. You are encouraged to examine the Caffe2 documentation for a list of operators. After studying the purpose of various operators, you would be in a position to create complex networks and train them. For training the network, Caffe2 provides several&nbsp;<strong>predefined computation units</strong>&nbsp;&#8211; that is the operators. You will need to select the appropriate operators for training your network for the kind of problem that you are trying to solve.</p>\n\n\n\n<p>Once a network is trained to your satisfaction, you can store it in a model file similar to the pre-trained model files you used earlier. These trained models may be contributed to Caffe2 repository for the benefits of other users. Or you may simply put the trained model for your own private production use.</p>\n\n\n\n<h2>Summary</h2>\n\n\n\n<p>Caffe2, which is a deep learning framework allows you to experiment with several kinds of neural networks for predicting your data. Caffe2 site provides many pre-trained models. You learned to use one of the pre-trained models for classifying objects in a given image. You also learned to define a neural network architecture of your choice. Such custom networks can be trained using many predefined operators in Caffe. A trained model is stored in a file which can be taken into a production environment.</p>\n","protected":false},"excerpt":{"rendered":"<p>In the previous lesson, you learned to create a trivial network and learned how to execute it and examine its output. The process for creating complex networks is similar to the process described above. Caffe2 provides a huge set of operators for creating complex architectures. You are encouraged to examine the Caffe2 documentation for a [&hellip;]</p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[90,156],"tags":[],"_links":{"self":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3361"}],"collection":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts"}],"about":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/types/post"}],"author":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/users/1"}],"replies":[{"embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/comments?post=3361"}],"version-history":[{"count":1,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3361/revisions"}],"predecessor-version":[{"id":4362,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/posts/3361/revisions/4362"}],"wp:attachment":[{"href":"https://python3.foobrdigital.com/wp-json/wp/v2/media?parent=3361"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/categories?post=3361"},{"taxonomy":"post_tag","embeddable":true,"href":"https://python3.foobrdigital.com/wp-json/wp/v2/tags?post=3361"}],"curies":[{"name":"wp","href":"https://api.w.org/{rel}","templated":true}]}}]