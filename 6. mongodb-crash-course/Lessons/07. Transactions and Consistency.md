# Transactions and Consistency

In this lesson, we will explore transactions in MongoDB and how they can ensure data consistency across multiple operations.

## Understanding Transactions

Transactions are a powerful feature in MongoDB that allow you to perform multiple operations as a single atomic unit. This means that either all the operations in a transaction are successfully applied, or none of them are applied at all. This ensures data consistency and integrity.

Transactions in MongoDB are implemented using the multi-document ACID (Atomicity, Consistency, Isolation, Durability) transaction model. This means that transactions can span multiple documents and collections, and provide the same level of consistency and isolation as traditional relational databases.

## Implementing Multi-Document Transactions

To implement multi-document transactions in MongoDB, you need to use the `session` object provided by the MongoDB driver. A session represents a logical transaction and allows you to group multiple operations together.

Here's an example of how to use transactions in MongoDB:

```javascript
const session = client.startSession();

session.startTransaction();

try {
  // Perform multiple operations within the transaction
  await collection1.insertOne({ name: "Document 1" }, { session });
  await collection2.updateOne({ _id: ObjectId("123") }, { $set: { name: "Updated Document" } }, { session });
  
  // Commit the transaction
  await session.commitTransaction();
} catch (error) {
  // Handle any errors and abort the transaction
  console.error("Error occurred, aborting transaction:", error);
  await session.abortTransaction();
} finally {
  // End the session
  session.endSession();
}
```

In this example, we start a session using `client.startSession()`, begin the transaction with `session.startTransaction()`, and perform multiple operations within the transaction. If any error occurs, we abort the transaction using `session.abortTransaction()`. Finally, we commit the transaction using `session.commitTransaction()` and end the session with `session.endSession()`.

## Practical Example: Using Transactions for a Banking Application

Let's consider a practical example of using transactions for a banking application. We have two collections: `accounts` and `transactions`. We want to transfer funds from one account to another while ensuring data consistency.

```javascript
const session = client.startSession();

session.startTransaction();

try {
  // Deduct funds from the sender's account
  await accounts.updateOne({ _id: senderId }, { $inc: { balance: -amount } }, { session });

  // Add funds to the recipient's account
  await accounts.updateOne({ _id: recipientId }, { $inc: { balance: amount } }, { session });

  // Record the transaction
  await transactions.insertOne({ senderId, recipientId, amount }, { session });

  // Commit the transaction
  await session.commitTransaction();
} catch (error) {
  // Handle any errors and abort the transaction
  console.error("Error occurred, aborting transaction:", error);
  await session.abortTransaction();
} finally {
  // End the session
  session.endSession();
}
```

In this example, we deduct funds from the sender's account, add funds to the recipient's account, and record the transaction in the `transactions` collection. If any error occurs, we abort the transaction. Otherwise, we commit the transaction, ensuring that the transfer of funds and the recording of the transaction are atomic.

## Exercise: Implement Data Consistency Across Multiple Operations

Now it's your turn to practice implementing data consistency across multiple operations using transactions. Consider a scenario where you have a `users` collection and a `orders` collection. Implement a transaction that inserts a new user and creates an order for that user. Make sure that both operations are either successfully applied or none of them are applied at all.

```javascript
const session = client.startSession();

session.startTransaction();

try {
  // Insert a new user
  await users.insertOne({ name: "John Doe" }, { session });

  // Create an order for the user
  await orders.insertOne({ userId: ObjectId("123"), product: "Example Product" }, { session });

  // Commit the transaction
  await session.commitTransaction();
} catch (error) {
  // Handle any errors and abort the transaction
  console.error("Error occurred, aborting transaction:", error);
  await session.abortTransaction();
} finally {
  // End the session
  session.endSession();
}
```

In this exercise, you need to complete the code by replacing `users` and `orders` with the actual collection names and `ObjectId("123")` with the appropriate user ID. Test the transaction by running the code and verifying that both the user and the order are either successfully inserted or none of them are inserted.

Congratulations! You have successfully learned about transactions in MongoDB and how to ensure data consistency across multiple operations. Transactions are a powerful feature that can help you maintain the integrity of your data in complex scenarios.